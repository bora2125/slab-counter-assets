<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AZA Slab Counter v8.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif;
            background: #ffffff;
            color: #333;
            min-height: 100vh;
            padding: 0;
            line-height: 1.6;
        }

        .container {
            width: 100%;
            height: 100vh;
            margin: 0;
            background: #ffffff;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-radius: 0;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.1);
        }

        .app-title {
            background: #1947BA;
            color: white;
            padding: 20px 25px;
            border-radius: 0;
            margin-bottom: 0;
            text-align: left;
            box-shadow: 0 8px 32px rgba(25, 71, 186, 0.4);
            border-bottom: 1px solid #dee2e6;
            backdrop-filter: blur(10px);
        }

        .app-title h1 {
            font-size: 1.5em;
            margin-bottom: 3px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .app-title p {
            margin: 0;
            font-size: 0.8em;
            opacity: 0.9;
        }

        .version-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            margin-left: 10px;
            font-weight: bold;
        }

        .content {
            padding: 20px;
            flex: 1;
            overflow: hidden;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 380px 1fr 350px;
            gap: 20px;
            height: calc(100vh - 40px);
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            padding-right: 10px;
            scrollbar-width: thin;
            scrollbar-color: #1947BA #ffffff;
        }
        
        .left-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .left-panel::-webkit-scrollbar-track {
            background: #ffffff;
            border-radius: 4px;
        }
        
        .left-panel::-webkit-scrollbar-thumb {
            background: #1947BA;
            border-radius: 4px;
        }
        
        .left-panel::-webkit-scrollbar-thumb:hover {
            background: #008759;
        }

        .center-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            height: 100%;
            position: relative;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            padding-right: 10px;
            scrollbar-width: thin;
            scrollbar-color: #1947BA #ffffff;
        }
        
        .right-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .right-panel::-webkit-scrollbar-track {
            background: #ffffff;
            border-radius: 3px;
        }
        
        .right-panel::-webkit-scrollbar-thumb {
            background: #1947BA;
            border-radius: 3px;
        }

        .upload-section {
            border: 3px dashed #1947BA;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            height: fit-content;
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.05) 0%, rgba(104, 109, 224, 0.05) 100%);
        }

        .upload-section:hover {
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.1) 0%, rgba(104, 109, 224, 0.1) 100%);
            border-color: #1947BA;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(72, 52, 212, 0.2);
        }

        .upload-section.dragover {
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.15) 0%, rgba(104, 109, 224, 0.15) 100%);
            border-color: #008759;
            transform: scale(1.02);
        }

        .file-input {
            display: none;
        }

        .btn {
            background: #1947BA;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
            margin: 8px;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.5);
            background: #1947BA;
        }

        .btn:disabled {
            background: #393D47;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            opacity: 0.6;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.05) 0%, rgba(104, 109, 224, 0.05) 100%);
            border-radius: 10px;
            border: 1px solid rgba(72, 52, 212, 0.2);
        }

        .slider-container {
            width: 100%;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1947BA;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(72, 52, 212, 0.3);
        }

        .single-image-container {
            width: 100%;
        }

        .preview-section {
            display: none;
        }

        .result-section {
            display: none;
        }

        .preview-info {
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.1) 0%, rgba(104, 109, 224, 0.1) 100%);
            border: 1px solid #1947BA;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .result-info {
            background: #f0f8f0;
            border: 1px solid #008759;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .result-info.error {
            background: #ffe8e8;
            border-color: #f44336;
        }

        .edit-mode-indicator {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            text-align: center;
            font-size: 14px;
            color: #856404;
            display: none;
        }

        .image-container {
            position: relative;
            display: inline-block;
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 20px;
            background: #f9f9f9;
            overflow: hidden;
            min-height: 460px;
            width: 100%;
            text-align: center;
        }

        .image-container img {
            max-width: 100%;
            max-height: 575px;
            border-radius: 8px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            cursor: zoom-in;
            transition: transform 0.3s ease;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            pointer-events: auto;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .image-container.edit-mode img {
            cursor: crosshair;
        }

        .point {
            position: absolute;
            width: 11px;
            height: 11px;
            border-radius: 50%;
            border: 1px solid white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 6px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            z-index: 10;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }

        .point.original {
            background-color: #ff0000;
        }

        .point.manual {
            background-color: #00ff00;
        }

        .point.selected {
            background-color: #ffff00;
            border: 2px solid #ff6600;
        }

        .point.batch {
            color: white;
            border: 2px solid white;
            font-weight: bold;
        }

        .selection-rectangle {
            position: absolute;
            border: 2px dashed #ff6600;
            background: rgba(255, 102, 0, 0.1);
            pointer-events: none;
            z-index: 15;
            display: none;
        }

        .mode-selector {
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.1) 0%, rgba(104, 109, 224, 0.1) 100%);
            border: 1px solid #1947BA;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .mode-selector h4 {
            margin-bottom: 10px;
            color: #393D47;
        }

        .mode-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .mode-btn {
            background: #f0f0f0;
            border: 2px solid #ddd;
            border-radius: 6px;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: #1947BA;
            color: white;
            border-color: #4834d4;
            box-shadow: 0 2px 8px rgba(72, 52, 212, 0.3);
        }

        .batch-controls {
            display: none;
            margin-top: 10px;
        }

        .batch-controls.active {
            display: block;
        }

        .batch-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .batch-input {
            width: 80px;
            padding: 5px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .assign-btn {
            background: #1947BA;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .assign-btn:hover {
            background: #008759;
            transform: translateY(-1px);
        }

        .assign-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .point:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #1947BA;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            font-weight: bold;
            z-index: 10000;
            max-width: 400px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            animation: slideInRight 0.3s ease-out;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .alert button:hover {
            background-color: rgba(255, 255, 255, 0.2) !important;
            transform: scale(1.1);
        }

        @keyframes slideInRight {
            0% {
                transform: translateX(100%);
                opacity: 0;
            }
            100% {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert-success {
            background: #ffffff;
            color: #046648;
            border: 1px solid #008759;
        }

        .alert-error {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #f44336;
        }

        .alert-warning {
            background: #fff8e1;
            color: #f57c00;
            border: 1px solid #ffb74d;
        }
        
        /* Modal para número de lote */
        .modal-close-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s, color 0.2s;
        }
        
        .modal-close-btn:hover {
            background-color: rgba(0, 0, 0, 0.1);
            color: #333;
        }
        
        .modal-close-btn:active {
            background-color: rgba(0, 0, 0, 0.2);
        }
        .batch-modal {
            display: none;
            position: fixed;
            z-index: 20000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.3s ease-out;
        }
        
        .batch-modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 30px;
            border-radius: 15px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
            animation: slideInDown 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        
        @keyframes slideInDown {
            0% {
                transform: translateY(-50px);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .batch-modal h3 {
            margin: 0 0 20px 0;
            color: #393D47;
            font-size: 1.3em;
        }
        
        .batch-modal-input {
            width: 120px;
            padding: 12px 15px;
            border: 2px solid #1947BA;
            border-radius: 8px;
            font-size: 1.2em;
            text-align: center;
            margin: 20px 0;
            font-weight: bold;
        }
        
        .batch-modal-input:focus {
            outline: none;
            border-color: #1947BA;
            box-shadow: 0 0 10px rgba(72, 52, 212, 0.3);
        }
        
        .batch-modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }
        
        .batch-modal-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .batch-modal-btn.confirm {
            background: #1947BA;
            color: white;
        }
        
        .batch-modal-btn.confirm:hover {
            background: #393D47;
            transform: translateY(-2px);
        }
        
        .batch-modal-btn.cancel {
            background: #e9ecef;
            color: #495057;
        }
        
        .batch-modal-btn.cancel:hover {
            background: #dee2e6;
        }
        
        /* Estilos para modal centrado */
        .movable-modal {
            position: relative !important;
            margin: 0 auto !important;
        }
        
        /* Asegurar que el modal esté centrado */
        .batch-modal.centered {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        img {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto;
        }

        .image-container img {
            -webkit-context-menu: none;
            -moz-context-menu: none;
            context-menu: none;
        }

        .image-container {
            position: relative;
        }

        .image-container::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 40px;
            height: 40px;
            background: transparent;
            pointer-events: none;
            z-index: 5;
        }

        .images-list-section {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #dee2e6;
        }

        .section-header h3 {
            margin: 0;
            color: #333;
            font-weight: 600;
        }

        .section-header h4 {
            margin: 0;
            color: #333;
            font-size: 16px;
            font-weight: 600;
        }

        .images-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
        }

        .image-card {
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .image-card:hover {
            border-color: #4834d4;
            box-shadow: 0 2px 8px rgba(72, 52, 212, 0.2);
        }

        .image-card.active {
            border-color: #4834d4;
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.05) 0%, rgba(104, 109, 224, 0.05) 100%);
            box-shadow: 0 2px 8px rgba(72, 52, 212, 0.2);
        }

        .image-card-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .image-card .image-name {
            font-size: 12px;
            color: #393D47;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .image-card .image-status {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 4px;
            display: inline-block;
            width: fit-content;
            font-weight: 500;
        }

        .image-status.uploaded {
            background: #e8f5e8;
            color: #046648;
        }

        .image-status.detected {
            background: #e3f2fd;
            color: #1565c0;
        }

        .image-status.with-batches {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .image-status.editing {
            background: #fff3e0;
            color: #ef6c00;
        }

        .image-card .delete-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(255, 71, 87, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 11px;
            cursor: pointer;
            display: none;
        }

        .image-card:hover .delete-btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .active-image-section {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(72, 52, 212, 0.1);
        }

        .image-actions {
            display: flex;
            gap: 10px;
        }

        .btn-small {
            background: #1947BA;
            color: white;
            border: none !important;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .btn-small:hover {
            background: #008759;
            transform: translateY(-1px);
        }

        .btn-small:focus {
            outline: none !important;
            border: none !important;
            box-shadow: none !important;
        }

        .delete-batch-btn {
            background: white !important;
            color: #ff4757 !important;
            padding: 4px 8px !important;
            font-size: 10px !important;
            margin-left: 10px !important;
            border: 0 !important;
            border-width: 0 !important;
            border-style: none !important;
            border-color: transparent !important;
            outline: 0 !important;
            outline-width: 0 !important;
            outline-style: none !important;
            outline-color: transparent !important;
            box-shadow: none !important;
            border-radius: 4px !important;
            cursor: pointer !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            appearance: none !important;
        }

        .delete-batch-btn:hover {
            background: #ffffff !important;
            border: 0 !important;
            outline: 0 !important;
            box-shadow: none !important;
        }

        .delete-batch-btn:focus {
            background: white !important;
            border: 0 !important;
            border-width: 0 !important;
            border-style: none !important;
            border-color: transparent !important;
            outline: 0 !important;
            outline-width: 0 !important;
            outline-style: none !important;
            outline-color: transparent !important;
            box-shadow: none !important;
        }

        .delete-batch-btn:active {
            background: white !important;
            border: 0 !important;
            border-width: 0 !important;
            border-style: none !important;
            border-color: transparent !important;
            outline: 0 !important;
            outline-width: 0 !important;
            outline-style: none !important;
            outline-color: transparent !important;
            box-shadow: none !important;
        }

        .no-images-message {
            grid-column: 1 / -1;
        }

        .active-image-info {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(72, 52, 212, 0.1);
        }

        .active-image-details {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            padding: 4px 0;
            border-bottom: 1px solid #dee2e6;
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-row strong {
            color: #393D47;
        }

        .detail-row span {
            color: #666;
        }

        .batch-details {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            box-shadow: 0 2px 10px rgba(72, 52, 212, 0.1);
        }

        .batch-detail-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .batch-detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: #f8f9fa;
            border-radius: 5px;
            font-size: 11px;
        }

        .batch-detail-item .batch-number {
            font-weight: bold;
            color: #393D47;
        }

        .batch-detail-item .batch-count {
            color: #666;
            font-size: 10px;
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 10px;
        }

        /* Toggle de tema */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 50px;
            padding: 8px 16px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            color: white;
            font-size: 18px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }


    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <div class="main-layout">
                <!-- Panel Izquierdo: Controles -->
                <div class="left-panel">
                    <!-- Título de la aplicación -->
                    <div class="app-title">
                        <div style="display: flex; align-items: center; justify-content: center; gap: 15px;">
                            <img src="logo_aza.JPG" alt="AZA Logo" style="height: 75px; width: auto;">
                            <span class="version-badge">Latest v8.0</span>
                        </div>
                    </div>
                    
                    
                    <!-- Sección de subida -->
                    <div class="upload-section" id="uploadArea">
                        <h3>📸 Subir Imágenes</h3>
                        <p>Arrastra múltiples imágenes aquí o haz click para seleccionar</p>
                        <button class="btn" onclick="document.getElementById('fileInput').click()">
                            Seleccionar Imágenes
                        </button>
                        <input type="file" id="fileInput" class="file-input" 
                               accept=".jpg,.jpeg,.png,.bmp,.tiff,.webp" multiple>
                        <div id="uploadStatus" style="margin-top: 10px; font-size: 12px; color: #666;"></div>
                    </div>

                    <!-- Controles -->
                    <div class="controls">
                        <div class="slider-container">
                            <label><strong>Confidence Threshold:</strong></label>
                            <input type="range" id="confidenceSlider" class="slider" 
                                   min="0.1" max="1.0" step="0.01" value="0.60">
                            <div style="text-align: center; margin-top: 10px;">
                                <span id="confidenceValue">0.60</span>
                            </div>
                        </div>
                        <button id="detectBtn" class="btn" onclick="detectSlabs()" disabled>
                            🚀 DETECTAR PALANQUILLAS
                        </button>
                    </div>

                    <!-- Selector de Modo de Edición -->
                    <div class="mode-selector" id="modeSelector" style="display: none;">
                        <h4>🔧 Modo de Edición</h4>
                        <div class="mode-buttons">
                            <div class="mode-btn" id="slabsMode" onclick="switchEditMode('slabs')">
                                ✏️ Editar Slabs
                            </div>
                            <div class="mode-btn active" id="batchesMode" onclick="switchEditMode('batches')">
                                📦 Selección de Lotes
                            </div>
                        </div>
                        
                        <!-- Controles para modo de lotes -->
                        <div class="batch-controls" id="batchControls">
                            <div style="font-size: 12px; color: #666; margin-bottom: 10px;">
                                📦 <strong>Gestión de Lotes</strong>
                            </div>
                            
                            <!-- Crear nuevo lote -->
                            <div class="batch-creation" style="margin-bottom: 15px; padding: 10px; background: linear-gradient(135deg, rgba(72, 52, 212, 0.05) 0%, rgba(104, 109, 224, 0.05) 100%); border-radius: 5px;">
                                <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
                                    1. Arrastra para seleccionar slabs
                                </div>
                                <div class="batch-input-group" style="display: none;">
                                    <button class="assign-btn" id="assignBatchBtn" onclick="openBatchModal()" disabled>
                                        📦 Crear Lote
                                    </button>
                                </div>
                                <div style="font-size: 11px; color: #666; text-align: center; padding: 10px; background: #f8f9fa; border-radius: 5px; margin-top: 10px;">
                                    📝 <strong>Instrucción:</strong><br>
                                    Dibuja un área para seleccionar slabs.<br>
                                    El popup de lote aparecerá automáticamente.
                                </div>
                                <div style="font-size: 10px; color: #888; margin-top: 5px;">
                                    Slabs seleccionados: <span id="selectedCount">0</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Loading -->
                    <div class="loading" id="loading">
                        <div class="spinner"></div>
                        <p>Procesando imagen con IA...</p>
                    </div>
                </div>

                <!-- Panel Central: Visualización de Imagen -->
                <div class="center-panel">
                    <!-- Controles de Zoom y Paneo -->
                    <div class="image-controls" id="imageControls" style="display: none;">
                        <div class="control-label">Zoom</div>
                        <div class="control-group">
                            <button class="control-btn" onclick="zoomIn()" title="Acercar (+)">
                                +
                            </button>
                            <div class="zoom-level" id="zoomLevel">100%</div>
                            <button class="control-btn" onclick="zoomOut()" title="Alejar (-)">
                                −
                            </button>
                        </div>
                        <div class="control-separator"></div>
                        <div class="control-group">
                            <button class="control-btn" onclick="resetZoom()" title="Restablecer zoom (0)">
                                🎯
                            </button>
                            <button class="control-btn" onclick="fitToScreen()" title="Ajustar a pantalla (F)">
                                📱
                            </button>
                        </div>
                        <div class="control-separator"></div>
                        <div class="control-label">Pan</div>
                        <div class="control-group">
                            <button class="control-btn" onclick="centerImage()" title="Centrar imagen (C)">
                                ⌖
                            </button>
                        </div>
                    </div>
                    <!-- Preview de imagen activa -->
                    <div class="preview-section" id="previewSection" style="display: none;">
                        <div class="section-header">
                            <h3>📷 Vista Previa</h3>
                            <div id="activeImageTitle" style="font-size: 12px; color: #666;">
                                Imagen cargada
                            </div>
                        </div>
                        <div class="image-container" id="previewContainer">
                            <p style="text-align: center; color: #999; padding: 60px;">
                                Vista previa aparecerá aquí
                            </p>
                        </div>
                    </div>

                    <!-- Resultados de imagen activa -->
                    <div class="result-section" id="resultSection" style="display: none;">
                        <div class="section-header">
                            <h3>🎯 Detección y Edición</h3>
                            <div class="image-actions">
                                <button id="previewBtn" class="btn-small" onclick="previewCurrentImage()" style="background: #1947BA;">
                                    👁️ Ver Original
                                </button>
                            </div>
                        </div>
                        <div class="edit-mode-indicator" id="editModeIndicator">
                            ✏️ <strong>Modo Edición:</strong> Click izquierdo para agregar puntos | Click derecho para eliminar puntos
                        </div>
                        <div class="image-container" id="imageContainer">
                            <p style="text-align: center; color: #999; padding: 60px;">
                                La imagen procesada aparecerá aquí
                            </p>
                        </div>
                    </div>

                    <!-- Mensaje cuando no hay imagen seleccionada -->
                    <div class="no-active-image" id="noActiveImage">
                        <div style="text-align: center; color: #999; padding: 100px 20px;">
                            <h3>📷 No hay imagen seleccionada</h3>
                            <p>Sube imágenes desde el panel izquierdo y selecciona una desde el panel derecho para comenzar</p>
                        </div>
                    </div>
                </div>

                <!-- Panel Derecho: Gestión de Imágenes -->
                <div class="right-panel">
                    <!-- Gestión de Imágenes -->
                    <div class="images-list-section">
                        <div class="section-header">
                            <h3>📂 Gestión de Imágenes</h3>
                            <div id="totalImagesCount" style="font-size: 11px; color: #666;">
                                Total: 0 imágenes
                            </div>
                        </div>
                        
                        <!-- Filtro por estado -->
                        <div class="filter-section" style="margin-bottom: 15px;">
                            <div style="font-size: 12px; font-weight: bold; color: #30336b; margin-bottom: 8px;">
                                🔍 Filtrar por Estado:
                            </div>
                            <select id="statusFilter" onchange="filterImagesByStatus()" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px;">
                                <option value="all" selected>Todas las imágenes</option>
                                <option value="uploaded">Cargado</option>
                                <option value="detected">Detectado</option>
                                <option value="with_batches">Con lotes</option>
                            </select>
                        </div>
                        
                        <div class="images-grid" id="imagesGrid">
                            <div class="no-images-message">
                                <p style="text-align: center; color: #999; padding: 20px; font-size: 12px;">
                                    📷 No hay imágenes<br>
                                    <small>Sube desde panel izquierdo</small>
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Botones CSV independientes debajo de Gestión de Imágenes -->
                    <div style="margin-bottom: 20px;">
                        <button class="btn" onclick="generateBatchCSV()" style="font-size: 12px; padding: 8px 12px; width: 100%; background: #008759; border: none; margin-bottom: 8px;">
                            📄 Descargar CSV de Lotes
                        </button>
                        <button class="btn" onclick="mostrarTablaHistorica()" style="font-size: 12px; padding: 8px 12px; width: 100%; background: #1947BA; border: none;">
                            📊 Ver Histórico de Lotes
                        </button>
                    </div>

                    <!-- Info de Imagen Activa -->
                    <div class="active-image-info" id="activeImageInfo" style="display: none;">
                        <div class="section-header">
                            <h4>🎯 Imagen Activa</h4>
                        </div>
                        <div class="active-image-details" id="activeImageDetails">
                            <div class="detail-row">
                                <strong>Nombre:</strong> <span id="activeImageName">-</span>
                            </div>
                            <div class="detail-row">
                                <strong>Estado:</strong> <span id="activeImageStatus">-</span>
                            </div>
                            <div class="detail-row">
                                <strong>Slabs en Lotes:</strong> <span id="activeImageSlabs">0</span>
                            </div>
                            <div class="detail-row">
                                <strong>Lotes:</strong> <span id="activeImageBatches">-</span>
                            </div>
                        </div>
                        
                        <!-- Detalle de slabs por lote -->
                        <div class="batch-details" id="batchDetails" style="display: none;">
                            <div class="section-header" style="margin-bottom: 10px;">
                                <h5 style="margin: 0; color: #30336b;">📊 Detalle por Lote</h5>
                            </div>
                            <div class="batch-detail-list" id="batchDetailList">
                                <!-- Se llenará dinámicamente -->
                            </div>
                        </div>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal para número de lote -->
    <div id="batchModal" class="batch-modal">
        <div class="batch-modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="margin: 0;">📦 Crear Nuevo Lote</h3>
                <button onclick="closeBatchModal()" class="modal-close-btn" title="Cerrar">✕</button>
            </div>
            <p style="margin: 10px 0; color: #666;">
                Tienes <span id="modalSelectedCount">0</span> slabs seleccionados
            </p>
            <p style="margin: 15px 0 5px 0; font-weight: bold; color: #30336b;">Número de Lote:</p>
            <input type="number" id="modalBatchNumber" class="batch-modal-input" value="1" min="1">
            <div class="batch-modal-buttons">
                <button class="batch-modal-btn cancel" onclick="closeBatchModal()">
                    ❌ Cancelar
                </button>
                <button class="batch-modal-btn confirm" onclick="confirmBatchAssignment()">
                    ✅ Crear Lote
                </button>
            </div>
        </div>
    </div>

    <!-- Modal para alertas de lotes duplicados -->
    <div id="duplicadoModal" class="batch-modal" style="display: none;">
        <div class="batch-modal-content" style="width: 500px; max-width: 90%; padding: 25px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="margin: 0; color: #e74c3c;">⚠️ Lote Duplicado Detectado</h3>
                <button onclick="cerrarModalDuplicado()" class="modal-close-btn" title="Cerrar">✕</button>
            </div>
            
            <div id="duplicadoInfo" style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <p style="margin: 0 0 10px 0; font-weight: bold; color: #856404;">📋 Información del Lote Existente:</p>
                <div id="duplicadoDetalles" style="font-size: 14px; color: #856404;">
                    <!-- Se llenará dinámicamente -->
                </div>
            </div>
            
            <p style="text-align: center; margin: 15px 0; color: #666; font-size: 14px;">
                El sistema creará una nueva entrada separada con el mismo número de lote.
            </p>
            
            <div style="text-align: center; margin-top: 20px;">
                <button id="duplicadoOkBtn" class="batch-modal-btn confirm" style="padding: 12px 30px; font-size: 16px;">
                    ✅ Entendido, Continuar
                </button>
            </div>
        </div>
    </div>

    <!-- Modal para tabla histórica -->
    <div id="tablaHistoricaModal" class="batch-modal" style="display: none;">
        <div id="tablaHistoricaContent" class="batch-modal-content movable-modal" style="width: 85%; max-width: 1200px; padding: 0; position: relative; max-height: 90vh; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
            <!-- Barra de título -->
            <div id="tablaHistoricaHeader" style="background: #1947BA; color: white; padding: 15px 20px; border-radius: 10px 10px 0 0; user-select: none; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h3 style="margin: 0; font-size: 16px;">📊 Histórico de Lotes</h3>
                    <p style="margin: 0; font-size: 11px; opacity: 0.9;">💡 Presiona ESC para cerrar</p>
                </div>
                <button onclick="cerrarTablaHistorica()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 14px;" title="Cerrar (ESC)">❌</button>
            </div>
            
            <!-- Contenido del modal -->
            <div style="padding: 20px; max-height: calc(90vh - 80px); overflow-y: auto;">
                <p style="text-align: center; font-size: 11px; color: #666; margin-bottom: 15px;">
                    📊 <strong>Histórico:</strong> Datos de solo lectura - No editable
                </p>
            
            <!-- Filtros -->
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd;">
                <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #333;">🔍 Filtros</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr auto; gap: 10px; align-items: end;">
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 3px;">Imagen:</label>
                        <input type="text" id="filtroImagen" placeholder="Filtrar por imagen..." 
                               style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 3px;">Número de Lote:</label>
                        <input type="text" id="filtroLote" placeholder="Ej: 777" 
                               style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 3px;">Fecha Desde:</label>
                        <input type="date" id="filtroFechaDesde" 
                               style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 3px;">Fecha Hasta:</label>
                        <input type="date" id="filtroFechaHasta" 
                               style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                    </div>
                    <div>
                        <button onclick="limpiarFiltrosHistorico()" 
                                style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">
                            🗑️ Limpiar
                        </button>
                    </div>
                </div>
            </div>
            
            <div id="tablaHistoricaContainer" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
                <table id="tablaHistorica" style="width: 100%; border-collapse: collapse; font-size: 12px;">
                    <thead style="background: #f8f9fa; position: sticky; top: 0;">
                        <tr>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Fecha</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Imagen</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Lote</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Slabs</th>
                        </tr>
                    </thead>
                    <tbody id="tablaHistoricaBody">
                        <!-- Se llenará dinámicamente -->
                    </tbody>
                </table>
                <div id="contadorRegistros" style="text-align: center; padding: 10px; font-size: 12px; color: #666; border-top: 1px solid #ddd;">
                    <!-- Se mostrará el conteo de registros filtrados -->
                </div>
            </div>
            
                <div style="text-align: center; display: flex; gap: 15px; justify-content: center; margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
                    <button class="batch-modal-btn" onclick="descargarCSVHistorico()" style="background: #008759; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                        📄 Descargar CSV
                    </button>
                    <button class="batch-modal-btn cancel" onclick="cerrarTablaHistorica()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                        🚪 Cerrar
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== FUNCIÓN DE TOGGLE DE TEMA =====
        
        function toggleTheme() {
            const body = document.body;
            const themeBtn = document.querySelector('.theme-toggle');
            
            if (body.classList.contains('light-theme')) {
                body.classList.remove('light-theme');
                themeBtn.textContent = '🌙';
                localStorage.setItem('theme', 'dark');
            } else {
                body.classList.add('light-theme');
                themeBtn.textContent = '☀️';
                localStorage.setItem('theme', 'light');
            }
        }

        // Restaurar tema guardado al cargar la página
        window.addEventListener('DOMContentLoaded', function() {
            const savedTheme = localStorage.getItem('theme');
            const body = document.body;
            const themeBtn = document.querySelector('.theme-toggle');
            
            if (savedTheme === 'light') {
                body.classList.add('light-theme');
                themeBtn.textContent = '☀️';
            } else {
                body.classList.remove('light-theme');
                themeBtn.textContent = '🌙';
            }
        });
        
        // ===== SISTEMA DE MÚLTIPLES IMÁGENES =====
        
        // Sistema de múltiples imágenes
        let uploadedImages = []; // Array de todas las imágenes cargadas
        let currentActiveImage = null; // Imagen actualmente seleccionada
        let nextImageId = 1;
        
        // Sistema de persistencia
        let persistentData = null;
        
        // Variable para recordar último número de lote ingresado
        let lastBatchNumber = 0;
        
        // Variables por imagen (se almacenan en uploadedImages)
        let currentFile = null;
        let manualPoints = [];
        let isEditMode = false;
        let nextPointId = 1;
        let imageScale = 1;
        let imageTranslateX = 0;
        let imageTranslateY = 0;
        let originalImageSrc = null;
        let isUpdatingPoints = false;
        
        // Estado del preview (toggle entre original y detecciones)
        let isPreviewMode = false; // false = con detecciones, true = solo imagen original
        
        // Nuevas variables para modo de selección de lotes
        let editModeType = 'batches'; // 'slabs' o 'batches' - batches por defecto
        let isDrawing = false;
        let selectionPath = []; // Para selección libre
        let selectedSlabs = [];
        let nextBatchNumber = 1;
        let batches = []; // Almacenamiento de lotes
        let currentImageName = ''; // Nombre de la imagen actual
        
        // COLORES PARA LOTES
        const batchColors = [
            '#7FBC03', // Verde principal AZA
            '#1947BA', // Azul principal AZA
            '#008759', // Verde oscuro AZA
            '#046648', // Verde muy oscuro AZA
            '#CCE29E', // Verde claro AZA
            '#174DFA', // Azul vibrante AZA
            '#999DA0', // Gris neutro AZA
            '#393D47', // Gris oscuro AZA
            '#438DC3', // Azul claro AZA
            '#A8D8EA'  // Azul muy claro AZA
        ];
        
        function getBatchColor(batchNumber) {
            return batchColors[(batchNumber - 1) % batchColors.length];
        }

        // ===== FUNCIONES DE PERSISTENCIA OPTIMIZADAS =====

        async function optimizePersistentData() {
            // Optimiza el archivo de persistencia eliminando datos pesados
            try {
                const response = await fetch('/optimize_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const result = await response.json();
                if (result.success) {
                    console.log('🔧 PERSISTENCIA OPTIMIZADA exitosamente');
                    return true;
                } else {
                    console.log('⚠️ Error optimizando persistencia:', result.error);
                    return false;
                }
            } catch (error) {
                console.log('⚠️ Error optimizando persistencia:', error);
                return false;
            }
        }

        async function loadPersistentData() {
            // Carga datos persistentes al inicializar la aplicación
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // Timeout de 5 segundos
                
                const response = await fetch('/load_persistent_data', {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    persistentData = result.data;
                    console.log(`📦 Datos persistentes cargados: ${persistentData.images.length} imágenes`);
                    return persistentData;
                } else {
                    console.log('📁 No hay datos persistentes previos');
                    return null;
                }
            } catch (error) {
                console.log('⚠️ Error o timeout cargando datos persistentes:', error.message);
                return null;
            }
        }

        async function saveImageDataToPersistence(imageData) {
            // Guarda datos de imagen en persistencia (no bloqueante)
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // Timeout de 5 segundos
                
                const response = await fetch('/save_image_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        imageData: {
                            name: imageData.name,
                            status: imageData.status,
                            manualPoints: imageData.manualPoints || [],
                            batches: imageData.batches || [],
                            nextPointId: imageData.nextPointId || 1,
                            // Solo enviar resumen de detección, NO datos completos pesados
                            detectionData: imageData.detectionData ? {
                                count: imageData.detectionData.count || 0,
                                fromPersistence: imageData.detectionData.fromPersistence || false
                            } : null,
                            createdAt: imageData.createdAt,
                            updatedAt: new Date().toISOString()
                        }
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                if (result.success) {
                    console.log(`💾 Datos guardados para: ${imageData.name}`);
                    return true;
                } else {
                    console.log('⚠️ Error guardando:', result.error);
                    return false;
                }
            } catch (error) {
                console.log('⚠️ Error o timeout guardando datos:', error.message);
                return false; // No bloquear si hay error
            }
        }

        async function loadImageDataFromPersistence(filename) {
            // Carga datos de imagen específica desde persistencia
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // Timeout de 5 segundos
                
                const response = await fetch(`/get_image_data/${encodeURIComponent(filename)}`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    console.log(`📂 Datos cargados para: ${filename}`);
                    return result.data;
                } else {
                    console.log(`📁 No hay datos persistentes para: ${filename}`);
                    return null;
                }
            } catch (error) {
                console.log(`⚠️ Error o timeout cargando datos para ${filename}:`, error.message);
                return null; // No bloquear si hay error
            }
        }


        // Configurar slider
        const confidenceSlider = document.getElementById('confidenceSlider');
        const confidenceValue = document.getElementById('confidenceValue');
        
        confidenceSlider.addEventListener('input', function() {
            confidenceValue.textContent = parseFloat(this.value).toFixed(2);
        });

        // Configurar drag & drop
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleMultipleFiles(Array.from(files));
            }
        });

        fileInput.addEventListener('change', function() {
            if (this.files.length > 0) {
                handleMultipleFiles(Array.from(this.files));
            }
        });

        function handleMultipleFiles(files) {
            if (files.length === 0) return;
            
            // Filtrar archivos duplicados
            const existingNames = uploadedImages.map(img => img.name);
            const newFiles = files.filter(file => {
                if (existingNames.includes(file.name)) {
                    showAlert(`Imagen ya cargada: ${file.name}`, 'error');
                    return false;
                }
                return true;
            });
            
            if (newFiles.length === 0) {
                document.getElementById('uploadStatus').textContent = 'Todas las imágenes ya están cargadas';
                return;
            }
            
            document.getElementById('uploadStatus').textContent = `Procesando ${newFiles.length} archivo(s) nuevo(s)...`;
            let successCount = 0;
            let errorCount = 0;
            
            newFiles.forEach((file, index) => {
                setTimeout(() => {
                    handleSingleFile(file).then(success => {
                        if (success) successCount++;
                        else errorCount++;
                        
                        // Actualizar estado cuando termine el último archivo
                        if (successCount + errorCount === newFiles.length) {
                            const statusMsg = `✅ ${successCount} imagen(es) cargada(s)` + 
                                            (errorCount > 0 ? ` | ❌ ${errorCount} error(es)` : '');
                            document.getElementById('uploadStatus').textContent = statusMsg;
                            updateImagesGrid();
                            
                            // Auto-seleccionar la primera imagen si no hay ninguna activa
                            // DELAY para permitir que la restauración de datos termine COMPLETAMENTE
                            if (!currentActiveImage && uploadedImages.length > 0) {
                                setTimeout(() => {
                                    selectImage(uploadedImages[0].id);
                                }, 500); // Medio segundo de delay
                            }
                        }
                    });
                }, index * 200); // Delay para evitar sobrecarga
            });
        }
        
        function handleSingleFile(file) {
            return new Promise((resolve) => {
                // Validar archivo
                const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/bmp', 'image/tiff', 'image/webp'];
                if (!allowedTypes.includes(file.type)) {
                    showAlert(`Tipo no permitido: ${file.name}`, 'error');
                    resolve(false);
                    return;
                }

                if (file.size > 16 * 1024 * 1024) {
                    showAlert(`Archivo muy grande: ${file.name}`, 'error');
                    resolve(false);
                    return;
                }

                // Crear objeto imagen
                const imageObj = {
                    id: nextImageId++,
                    name: file.name,
                    file: file,
                    status: 'uploading',
                    uploadData: null,
                    detectionData: null,
                    manualPoints: [],
                    batches: [],
                    nextPointId: 1,
                    originalImageSrc: null,
                    createdAt: new Date().toISOString()
                };

                // Agregar a la lista
                uploadedImages.push(imageObj);

                // Subir archivo
                const formData = new FormData();
                formData.append('file', file);

                fetch('/upload', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        imageObj.status = 'uploaded';
                        imageObj.uploadData = data;
                        
                        // Generar preview y cargar datos persistentes
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            imageObj.originalImageSrc = e.target.result;
                            
                            // CARGAR DATOS PERSISTENTES DE FORMA ROBUSTA
                            loadImageDataFromPersistence(file.name)
                                .then(persistedData => {
                                    if (persistedData) {
                                        console.log(`📂 DATOS ENCONTRADOS para ${file.name}:`, persistedData);
                                        
                                        // Restaurar datos persistentes OPTIMIZADOS
                                        imageObj.manualPoints = persistedData.manualPoints || [];
                                        imageObj.batches = persistedData.batches || [];
                                        imageObj.nextPointId = persistedData.nextPointId || 1;
                                        
                                        // Usar detectionSummary en lugar de detectionData completo
                                        if (persistedData.detectionSummary) {
                                            imageObj.detectionData = {
                                                success: true,
                                                count: persistedData.detectionSummary.count,
                                                fromPersistence: true  // Marcar que viene de persistencia
                                            };
                                        } else {
                                            imageObj.detectionData = null;
                                        }
                                        
                                        // Determinar estado correcto
                                        if (persistedData.batches && persistedData.batches.length > 0) {
                                            imageObj.status = 'with-batches';
                                            console.log(`🔄 IMAGEN RESTAURADA: ${file.name} - ${imageObj.manualPoints.length} slabs, ${imageObj.batches.length} lotes`);
                                        } else if (persistedData.detectionData) {
                                            imageObj.status = 'detected';
                                            console.log(`🔄 IMAGEN DETECTADA RESTAURADA: ${file.name} - ${imageObj.manualPoints.length} slabs`);
                                        }
                                        
                                        // Actualizar UI inmediatamente
                                        updateImagesGrid();
                                        
                                        // Si es la imagen activa, actualizar la vista
                                        if (currentActiveImage && currentActiveImage.id === imageObj.id) {
                                            updateActiveImageInfo();
                                        }
                                        
                                        console.log(`✅ PERSISTENCIA RESTAURADA para: ${file.name}`);
                                    } else {
                                        console.log(`📁 No hay datos persistentes para: ${file.name}`);
                                    }
                                })
                                .catch(error => {
                                    console.log(`⚠️ Error cargando persistencia para ${file.name}:`, error);
                                })
                                .finally(() => {
                                    // Actualizar UI al final
                                    updateImagesGrid();
                                });
                            
                            resolve(true);
                        };
                        reader.readAsDataURL(file);
                    } else {
                        imageObj.status = 'error';
                        resolve(false);
                    }
                })
                .catch(error => {
                    console.error('Error subiendo:', file.name, error);
                    imageObj.status = 'error';
                    resolve(false);
                });
            });
        }
        
        function updateImagesGrid(filteredImages = null) {
            const grid = document.getElementById('imagesGrid');
            const totalCount = document.getElementById('totalImagesCount');
            const filterStatus = document.getElementById('statusFilter').value;
            
            // Si no se proporcionan imágenes filtradas, aplicar el filtro actual
            let imagesToShow;
            if (filteredImages !== null) {
                imagesToShow = filteredImages;
            } else if (filterStatus !== 'all') {
                // Aplicar filtro automáticamente
                imagesToShow = uploadedImages.filter(img => {
                    switch (filterStatus) {
                        case 'uploaded':
                            return img.status === 'uploaded' && (!img.batches || img.batches.length === 0) && !img.detectionData;
                        case 'detected':
                            return img.status === 'detected' || (img.detectionData && (!img.batches || img.batches.length === 0));
                        case 'with_batches':
                            return img.batches && img.batches.length > 0;
                        default:
                            return true;
                    }
                });
            } else {
                imagesToShow = uploadedImages;
            }
            
            // Debug log para rastrear estados
            if (imagesToShow.length === 1) {
                const img = imagesToShow[0];
                console.log(`🔍 DEBUG imagen única: ${img.name}`);
                console.log(`   - Status: ${img.status}`);
                console.log(`   - Batches: ${img.batches ? img.batches.length : 0}`);
                console.log(`   - ManualPoints: ${img.manualPoints ? img.manualPoints.length : 0}`);
                console.log(`   - DetectionData: ${img.detectionData ? 'Sí' : 'No'}`);
            }
            
            // Actualizar contador
            if (filterStatus === 'all') {
                totalCount.textContent = `Total: ${uploadedImages.length} imágenes`;
            } else {
                totalCount.textContent = `Mostrando: ${imagesToShow.length} de ${uploadedImages.length} imágenes`;
            }
            
            if (imagesToShow.length === 0) {
                const noResultsMessage = filterStatus === 'all' ? 
                    'No hay imágenes<br><small>Sube desde panel izquierdo</small>' :
                    'No hay imágenes con este estado<br><small>Prueba otro filtro</small>';
                    
                grid.innerHTML = `
                    <div class="no-images-message">
                        <p style="text-align: center; color: #999; padding: 20px; font-size: 12px;">
                            📷 ${noResultsMessage}
                        </p>
                    </div>
                `;
                return;
            }
            
            const cardsHtml = imagesToShow.map(img => {
                // Debug para imagen única - RASTREAR EL PROBLEMA
                if (imagesToShow.length === 1) {
                    console.log(`🔥 ACTUALIZANDO GRID - IMAGEN ÚNICA: ${img.name}`);
                    console.log(`   - Status interno: '${img.status}'`);
                    console.log(`   - Batches: ${img.batches?.length || 0}`);
                    console.log(`   - ManualPoints: ${img.manualPoints?.length || 0}`);
                    console.log(`   - DetectionData: ${img.detectionData ? 'Sí' : 'No'}`);
                }
                
                // Determinar estado más preciso y robusto
                let statusClass, statusText;
                
                // 1. Prioridad máxima: si tiene lotes definidos
                if (img.batches && img.batches.length > 0) {
                    statusClass = 'with-batches';
                    statusText = 'Con Lotes';
                // 2. Si tiene puntos manuales o datos de detección
                } else if (img.manualPoints && img.manualPoints.length > 0) {
                    statusClass = 'detected';
                    statusText = 'Detectado';
                // 3. Si tiene datos de detección (incluso sin puntos)
                } else if (img.detectionData && img.detectionData.count > 0) {
                    statusClass = 'detected';
                    statusText = 'Detectado';
                // 4. Estados específicos del flujo
                } else if (img.status === 'editing') {
                    statusClass = 'editing';
                    statusText = 'Editando';
                } else if (img.status === 'with-batches') {
                    statusClass = 'with-batches';
                    statusText = 'Con Lotes';
                } else if (img.status === 'detected') {
                    statusClass = 'detected';
                    statusText = 'Detectado';
                } else if (img.status === 'uploaded') {
                    statusClass = 'uploaded';
                    statusText = 'Cargado';
                // 5. Por defecto: cargado (NO "procesando")
                } else {
                    statusClass = 'uploaded';
                    statusText = 'Cargado';
                }
                
                // Debug final para imagen única
                if (imagesToShow.length === 1) {
                    console.log(`🎯 ESTADO FINAL DETERMINADO: ${statusText} (${statusClass})`);
                }
                
                const activeClass = currentActiveImage && currentActiveImage.id === img.id ? 'active' : '';
                
                return `
                    <div class="image-card ${activeClass}" onclick="selectImage(${img.id})">
                        <button class="delete-btn" onclick="deleteImage(${img.id}); event.stopPropagation();">✖</button>
                        <div class="image-card-content">
                            <div class="image-name" title="${img.name}">${img.name}</div>
                            <div class="image-status ${statusClass}">${statusText}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            grid.innerHTML = cardsHtml;
        }
        
        function filterImagesByStatus() {
            // Simplemente actualizar el grid, que ahora detecta automáticamente el filtro
            updateImagesGrid();
        }
        
        function clearAllVisualElements() {
            // Limpiar completamente todos los elementos visuales
            hideResults();
            hidePreview();
            clearSelection();
            hideFreeSelection();
            resetImageTransform();
            
            // Limpiar contenedores de imagen
            const previewContainer = document.getElementById('previewContainer');
            const imageContainer = document.getElementById('imageContainer');
            if (previewContainer) previewContainer.innerHTML = '';
            if (imageContainer) imageContainer.innerHTML = '';
            
            // Limpiar overlays SVG si existen
            const svgOverlays = document.querySelectorAll('svg');
            svgOverlays.forEach(svg => {
                if (svg.classList.contains('point-overlay') || svg.classList.contains('selection-overlay')) {
                    svg.remove();
                }
            });
            
            // Limpiar puntos y elementos dinámicos
            const dynamicPoints = document.querySelectorAll('.point, .manual-point, .selection-rect');
            dynamicPoints.forEach(point => point.remove());
            
            // Resetear variables de selección
            selectedSlabs = [];
            isEditMode = false;
            editModeType = 'slabs';
        }
        
        async function selectImage(imageId) {
            // Guardar datos de imagen actual antes de cambiar
            if (currentActiveImage) {
                await saveCurrentImageData(); // GUARDADO SÍNCRONO antes de cambiar
            }
            
            // CRITICAL: Limpiar completamente todos los elementos visuales de la imagen anterior
            clearAllVisualElements();
            
            // Cargar nueva imagen
            const imageObj = uploadedImages.find(img => img.id === imageId);
            if (!imageObj) return;
            
            currentActiveImage = imageObj;
            
            // Restaurar variables globales CON DATOS PERSISTENTES
            currentFile = imageObj.uploadData;
            manualPoints = [...(imageObj.manualPoints || [])];
            batches = [...(imageObj.batches || [])];
            nextPointId = imageObj.nextPointId || 1;
            originalImageSrc = imageObj.originalImageSrc;
            currentImageName = imageObj.name;
            
            console.log(`🔄 SELECCIONANDO IMAGEN: ${imageObj.name}`);
            console.log(`   📊 Manual Points: ${manualPoints.length}`);
            console.log(`   📦 Batches: ${batches.length}`);
            console.log(`   🎯 Status: ${imageObj.status}`);
            
            // Actualizar interfaz del panel central
            document.getElementById('activeImageTitle').textContent = imageObj.name;
            document.getElementById('noActiveImage').style.display = 'none';
            
            // Mostrar preview
            if (imageObj.originalImageSrc) {
                showPreviewForImage(imageObj);
            }
            
            // Habilitar detección si está cargada
            document.getElementById('detectBtn').disabled = !imageObj.uploadData;
            
            // Si ya tiene detección O datos persistentes, mostrar resultados
            if (imageObj.detectionData || (imageObj.manualPoints && imageObj.manualPoints.length > 0)) {
                console.log(`🎯 Mostrando resultados porque tiene datos: detectionData=${!!imageObj.detectionData}, manualPoints=${imageObj.manualPoints?.length || 0}`);
                showResultsForImage(imageObj);
            } else {
                console.log(`📁 No hay datos para mostrar, ocultando resultados`);
                hideResults();
            }
            
            // PRESERVAR estado ya establecido correctamente
            console.log(`🔍 ANTES de updateImagesGrid en selectImage: ${imageObj.name} tiene estado '${imageObj.status}'`);
            console.log(`   - Batches: ${imageObj.batches?.length || 0}`);
            console.log(`   - ManualPoints: ${imageObj.manualPoints?.length || 0}`);
            
            // Solo actualizar grid si el estado no está ya correctamente establecido
            // Evitar sobrescribir "with-batches" con "procesando"
            const shouldUpdateGrid = !(
                imageObj.status === 'with-batches' && 
                imageObj.batches && 
                imageObj.batches.length > 0
            );
            
            if (shouldUpdateGrid) {
                console.log(`🔄 Actualizando grid para ${imageObj.name}`);
                updateImagesGrid();
            } else {
                console.log(`🚫 NO actualizando grid para ${imageObj.name} - estado ya correcto: ${imageObj.status}`);
            }
            
            updateActiveImageInfo();
            
            // Inicializar estado del botón preview
            isPreviewMode = false; // Siempre inicia mostrando detecciones
            updatePreviewButtonText();
            
            console.log(`Imagen seleccionada: ${imageObj.name}`);
        }
        
        // ===== SISTEMA DE AUTO-GUARDADO ROBUSTO =====
        
        let saveTimeout = null;
        
        function autoSaveCurrentImageData() {
            // Auto-guardado con debounce para evitar spam
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            
            saveTimeout = setTimeout(() => {
                saveCurrentImageDataNow();
            }, 500); // Espera 500ms después del último cambio
        }
        
        async function saveCurrentImageDataNow() {
            if (!currentActiveImage) {
                console.log('⚠️ No hay imagen activa para guardar');
                return;
            }
            
            // Actualizar datos en el objeto imagen
            currentActiveImage.manualPoints = [...manualPoints];
            currentActiveImage.batches = [...batches];
            currentActiveImage.nextPointId = nextPointId;
            currentActiveImage.updatedAt = new Date().toISOString();
            
            console.log(`💾 AUTO-GUARDANDO DATOS para ${currentActiveImage.name}:`);
            console.log(`   📊 Manual Points: ${currentActiveImage.manualPoints.length}`);
            console.log(`   📦 Batches: ${currentActiveImage.batches.length}`);
            console.log(`   🕒 Timestamp: ${currentActiveImage.updatedAt}`);
            
            // GUARDAR EN PERSISTENCIA (sin bloquear)
            try {
                const saved = await saveImageDataToPersistence(currentActiveImage);
                
                if (saved) {
                    console.log(`✅ AUTO-GUARDADO EXITOSO para: ${currentActiveImage.name}`);
                    
                    // Actualizar estado visual
                    if (currentActiveImage.batches && currentActiveImage.batches.length > 0) {
                        currentActiveImage.status = 'with-batches';
                    } else if (currentActiveImage.manualPoints && currentActiveImage.manualPoints.length > 0) {
                        currentActiveImage.status = 'detected';
                    }
                    
                    updateImagesGrid();
                    updateActiveImageInfo();
                } else {
                    console.log(`❌ ERROR EN AUTO-GUARDADO para: ${currentActiveImage.name}`);
                }
            } catch (error) {
                console.log(`❌ EXCEPCIÓN EN AUTO-GUARDADO:`, error);
            }
        }
        
        // Función de guardado síncrono para casos críticos
        async function saveCurrentImageData() {
            return await saveCurrentImageDataNow();
        }
        
        function updateActiveImageInfo() {
            const infoPanel = document.getElementById('activeImageInfo');
            
            if (!currentActiveImage) {
                infoPanel.style.display = 'none';
                return;
            }
            
            infoPanel.style.display = 'block';
            
            // Actualizar detalles
            document.getElementById('activeImageName').textContent = currentActiveImage.name;
            
            // Determinar estado
            let status;
            if (currentActiveImage.batches && currentActiveImage.batches.length > 0) {
                status = 'Con Lotes Asignados';
            } else if (currentActiveImage.status === 'detected') {
                status = 'Detectado';
            } else if (currentActiveImage.status === 'editing') {
                status = 'En Edición';
            } else if (currentActiveImage.status === 'uploaded') {
                status = 'Cargado';
            } else {
                status = 'Procesando';
            }
            
            document.getElementById('activeImageStatus').textContent = status;
            // Calcular suma de slabs en lotes
            let slabsInBatches = 0;
            if (currentActiveImage.batches && currentActiveImage.batches.length > 0) {
                slabsInBatches = currentActiveImage.batches.reduce((total, batch) => total + batch.points.length, 0);
            }
            document.getElementById('activeImageSlabs').textContent = slabsInBatches;
            
            // Mostrar números de lotes y detalle
            if (currentActiveImage.batches && currentActiveImage.batches.length > 0) {
                const batchNumbers = currentActiveImage.batches.map(batch => batch.number).sort((a, b) => a - b);
                document.getElementById('activeImageBatches').textContent = batchNumbers.join(', ');
                
                // Mostrar detalle por lote
                const batchDetails = document.getElementById('batchDetails');
                const batchDetailList = document.getElementById('batchDetailList');
                
                batchDetails.style.display = 'block';
                
                const detailsHtml = currentActiveImage.batches
                    .sort((a, b) => a.number - b.number)
                    .map(batch => {
                        const batchColor = getBatchColor(batch.number);
                        return `
                            <div class="batch-detail-item" style="border-left: 4px solid ${batchColor};">
                                <div style="display: flex; flex-direction: column; flex: 1;">
                                    <span class="batch-number">Lote 
                                        <span class="editable-batch-number" 
                                              data-batch-id="${batch.number}" 
                                              onclick="editarNumeroLote(${batch.number})"
                                              style="cursor: pointer; background: rgba(255,255,255,0.2); padding: 2px 6px; border-radius: 4px; text-decoration: underline;"
                                              title="Click para editar">
                                            ${batch.number}
                                        </span>
                                    </span>
                                    <span class="batch-count">${batch.points.length} slabs</span>
                                </div>
                                <button class="delete-batch-btn" onclick="deleteBatch(${batch.number})">
                                    🗑️
                                </button>
                            </div>
                        `;
                    }).join('');
                
                batchDetailList.innerHTML = detailsHtml;
            } else {
                document.getElementById('activeImageBatches').textContent = '-';
                document.getElementById('batchDetails').style.display = 'none';
            }
        }
        
        function deleteImage(imageId) {
            if (!confirm('¿Estás seguro de eliminar esta imagen?')) return;
            
            const index = uploadedImages.findIndex(img => img.id === imageId);
            if (index === -1) return;
            
            const imageObj = uploadedImages[index];
            
            // Si es la imagen activa, limpiar
            if (currentActiveImage && currentActiveImage.id === imageId) {
                hideResults();
                hidePreview();
                document.getElementById('noActiveImage').style.display = 'block';
                currentActiveImage = null;
                currentFile = null;
                manualPoints = [];
                batches = [];
            }
            
            // Eliminar de la lista
            uploadedImages.splice(index, 1);
            
            // Actualizar interfaz
            updateImagesGrid();
            updateActiveImageInfo();
            
            // Si no hay imágenes activas pero hay otras, seleccionar la primera
            if (!currentActiveImage && uploadedImages.length > 0) {
                selectImage(uploadedImages[0].id);
            }
            
            showAlert(`Imagen eliminada: ${imageObj.name}`, 'success');
        }
        
        function deleteCurrentImage() {
            if (currentActiveImage) {
                deleteImage(currentActiveImage.id);
            }
        }
        
        function showPreviewForImage(imageObj) {
            const container = document.getElementById('previewContainer');
            container.innerHTML = `<img src="${imageObj.originalImageSrc}" alt="Vista previa" id="previewImg">`;
            document.getElementById('previewSection').style.display = 'block';
            
            // Agregar zoom functionality
            setTimeout(() => {
                addZoomFunctionality('previewImg');
            }, 100);
        }
        
        function showResultsForImage(imageObj) {
            console.log(`🎯 MOSTRANDO RESULTADOS para: ${imageObj.name}`);
            console.log(`   📊 Manual Points a cargar: ${imageObj.manualPoints?.length || 0}`);
            console.log(`   📦 Batches a cargar: ${imageObj.batches?.length || 0}`);
            
            // Cargar detecciones previas CON DATOS PERSISTENTES
            manualPoints = [...(imageObj.manualPoints || [])];
            batches = [...(imageObj.batches || [])];
            nextPointId = imageObj.nextPointId || 1;
            
            // Ocultar vista previa
            document.getElementById('previewSection').style.display = 'none';
            
            // Mostrar imagen original (sin puntos de YOLO)
            const container = document.getElementById('imageContainer');
            container.innerHTML = `<img src="${imageObj.originalImageSrc}" alt="Imagen para edición" id="resultImg">`;
            
            // Configurar modo edición
            setTimeout(() => {
                setupEditMode();
                renderPoints();
                console.log(`✅ PUNTOS RENDERIZADOS: ${manualPoints.length} slabs, ${batches.length} lotes`);
            }, 100);
            
            // Mostrar secciones
            document.getElementById('resultSection').style.display = 'block';
            document.getElementById('editModeIndicator').style.display = 'block';
            document.getElementById('modeSelector').style.display = 'block';
            isEditMode = true;
            
            // ACTIVAR MODO LOTES POR DEFECTO AL CARGAR IMAGEN EXISTENTE
            setTimeout(() => {
                switchEditMode('batches');
                console.log('📦 Modo lotes activado por defecto al cargar imagen existente');
            }, 200);
            
            // Actualizar estado
            imageObj.status = 'editing';
        }

        function detectSlabs() {
            if (!currentFile) {
                showAlert('❌ No hay imagen seleccionada', 'error');
                return;
            }
            
            if (!currentActiveImage) {
                showAlert('❌ No hay imagen activa', 'error');
                return;
            }

            const confidence = parseFloat(confidenceSlider.value);
            
            // Mostrar loading
            document.getElementById('loading').style.display = 'block';
            document.getElementById('detectBtn').disabled = true;
            hideResults();

            fetch('/detect', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    filepath: currentFile.filepath,
                    confidence: confidence
                })
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('detectBtn').disabled = false;

                if (data.success) {
                    // Guardar datos de detección en la imagen activa
                    currentActiveImage.detectionData = data;
                    currentActiveImage.status = 'detected';
                    
                    // GUARDAR INMEDIATAMENTE EN PERSISTENCIA
                    autoSaveCurrentImageData();
                    
                    showResults(data);
                    updateImagesGrid();
                    showAlert(`✅ Detección completada: ${data.count} palanquillas encontradas`, 'success');
                } else {
                    showAlert(`❌ Error en detección: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('detectBtn').disabled = false;
                showAlert('❌ Error en detección', 'error');
            });
        }

        function showResults(data) {
            // Inicializar puntos manuales con detecciones YOLO
            manualPoints = data.detections.map((detection, index) => ({
                id: index + 1,
                x: detection.x,
                y: detection.y,
                confidence: detection.confidence,
                isOriginal: true,
                batchNumber: null,
                isSelected: false
            }));
            nextPointId = manualPoints.length + 1;
            
            // Ocultar vista previa
            document.getElementById('previewSection').style.display = 'none';
            
            // Mostrar imagen original (sin puntos de YOLO)
            const container = document.getElementById('imageContainer');
            container.innerHTML = `<img src="${originalImageSrc}" alt="Imagen para edición" id="resultImg">`;
            
            // Configurar modo edición
            setTimeout(() => {
                setupEditMode();
                renderPoints();
            }, 100);
            
            // Mostrar secciones
            document.getElementById('resultSection').style.display = 'block';
            document.getElementById('editModeIndicator').style.display = 'block';
            document.getElementById('modeSelector').style.display = 'block';
            
            // ACTIVAR MODO LOTES POR DEFECTO DESPUÉS DE DETECCIÓN
            setTimeout(() => {
                switchEditMode('batches'); // Forzar modo lotes
                console.log('📦 Modo lotes activado por defecto después de detección');
            }, 200);
            isEditMode = true;
            
            // Activar automáticamente el modo "Selección de Lotes"
            switchEditMode('batches');
            
            // Scroll a resultados
            document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
        }

        function hideResults() {
            document.getElementById('resultSection').style.display = 'none';
            document.getElementById('editModeIndicator').style.display = 'none';
            document.getElementById('modeSelector').style.display = 'none';
            isEditMode = false;
            editModeType = 'points';
            selectedSlabs = [];
            manualPoints = [];
            resetImageTransform();
            // Mostrar vista previa nuevamente si existe currentFile
            if (currentFile) {
                document.getElementById('previewSection').style.display = 'block';
            }
        }

        function previewImage() {
            if (currentActiveImage && currentActiveImage.file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const container = document.getElementById('previewContainer');
                    container.innerHTML = `<img src="${e.target.result}" alt="Preview sin detecciones" id="previewImg">`;
                    document.getElementById('previewSection').style.display = 'block';
                    
                    // Ocultar resultados si existen
                    hideResults();
                    
                    // Habilitar zoom
                    addZoomFunctionality();
                    
                    showAlert('✅ Preview de imagen sin detecciones mostrado', 'success');
                };
                reader.readAsDataURL(currentActiveImage.file);
            } else {
                showAlert('❌ No hay imagen seleccionada para preview', 'error');
            }
        }
        
        function previewCurrentImage() {
            console.log('🔴 BUTTON PRESSED - previewCurrentImage() ejecutada');
            console.log('currentActiveImage:', currentActiveImage);
            console.log('currentActiveImage.detectionData:', currentActiveImage ? currentActiveImage.detectionData : 'No hay imagen activa');
            
            // Solo funciona si hay detecciones ejecutadas
            if (!currentActiveImage || !currentActiveImage.detectionData) {
                console.log('❌ No hay imagen o no hay detectionData');
                showAlert('❌ El preview solo funciona en imágenes con detección ejecutada', 'error');
                return;
            }
            
            // Toggle simple entre imagen original y imagen con detecciones
            isPreviewMode = !isPreviewMode;
            console.log('isPreviewMode cambiado a:', isPreviewMode);
            
            if (isPreviewMode) {
                // Mostrar imagen original sin detecciones
                console.log('🟡 Llamando showOriginalImage()');
                showOriginalImage();
            } else {
                // Mostrar imagen con detecciones
                console.log('🟢 Llamando showDetectedImage()');
                showDetectedImage();
            }
            
            // Actualizar botón
            updatePreviewButtonText();
        }
        
        function showOriginalImage() {
            console.log('📷 === EJECUTANDO showOriginalImage() ===');
            
            // Cambiar a imagen original
            const resultImg = document.getElementById('resultImg');
            if (resultImg && originalImageSrc) {
                resultImg.src = originalImageSrc;
                console.log('✅ Imagen cambiada a original');
            }
            
            // OCULTAR todos los puntos de detección (elementos DIV con clase .point)
            const pointElements = document.querySelectorAll('.point');
            console.log('Point elements encontrados:', pointElements.length);
            
            pointElements.forEach((point, index) => {
                point.style.display = 'none';
                console.log(`✅ Point ${index} ocultado`);
            });
            
            // También ocultar SVG overlays de selección
            const svgOverlays = document.querySelectorAll('svg');
            svgOverlays.forEach((svg, index) => {
                if (svg.id === 'selectionOverlay' || svg.classList.contains('selection-overlay')) {
                    svg.style.display = 'none';
                    console.log(`✅ SVG selection overlay ${index} ocultado`);
                }
            });
            
            console.log('📷 === IMAGEN ORIGINAL MOSTRADA ===');
        }
        
        function showDetectedImage() {
            console.log('🎯 === EJECUTANDO showDetectedImage() ===');
            
            // Volver a imagen original como base
            const resultImg = document.getElementById('resultImg');
            if (resultImg && originalImageSrc) {
                resultImg.src = originalImageSrc;
                console.log('✅ Imagen restaurada a original como base');
            }
            
            // MOSTRAR todos los puntos de detección (elementos DIV con clase .point)
            const pointElements = document.querySelectorAll('.point');
            console.log('Point elements encontrados:', pointElements.length);
            
            pointElements.forEach((point, index) => {
                point.style.display = 'block';
                console.log(`✅ Point ${index} mostrado`);
            });
            
            // Mostrar SVG overlays de selección
            const svgOverlays = document.querySelectorAll('svg');
            svgOverlays.forEach((svg, index) => {
                if (svg.id === 'selectionOverlay' || svg.classList.contains('selection-overlay')) {
                    svg.style.display = 'block';
                    console.log(`✅ SVG selection overlay ${index} mostrado`);
                }
            });
            
            // Re-renderizar puntos para asegurar que se muestren
            console.log('🔄 Re-renderizando puntos...');
            setTimeout(() => {
                renderPoints();
                console.log('✅ renderPoints() ejecutado');
            }, 50);
            
            
            console.log('🎯 === DETECCIONES MOSTRADAS ===');
        }
        
        function updatePreviewButtonText() {
            const previewBtn = document.getElementById('previewBtn');
            if (previewBtn) {
                if (isPreviewMode) {
                    previewBtn.innerHTML = '🎯 Ver Detecciones';
                } else {
                    previewBtn.innerHTML = '👁️ Ver Original';
                }
            }
        }

        function showPreview(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                originalImageSrc = e.target.result;
                const container = document.getElementById('previewContainer');
                container.innerHTML = `<img src="${e.target.result}" alt="Vista previa" id="previewImg">`;
                document.getElementById('previewSection').style.display = 'block';
                    
                // Agregar zoom functionality
                setTimeout(() => {
                    addZoomFunctionality('previewImg');
                }, 100);
                
                // Scroll a preview
                document.getElementById('previewSection').scrollIntoView({ behavior: 'smooth' });
            };
            reader.readAsDataURL(file);
        }

        function hidePreview() {
            document.getElementById('previewSection').style.display = 'none';
        }

        function setupEditMode() {
            const img = document.getElementById('resultImg');
            const container = document.getElementById('imageContainer');
            
            if (!img || !container) return;
            
            container.classList.add('edit-mode');
            
            // Event listeners para edición - esperar a que se cree el transformContainer
            setTimeout(() => {
                const transformContainer = document.getElementById('transformContainer');
                if (!transformContainer) return;
                
                // SISTEMA ROBUSTO: Calcular coordenadas precisas SIEMPRE
                function getAccurateCoordinates(e) {
                    // Obtener el rect de la imagen REAL en su posición actual
                    const imgRect = img.getBoundingClientRect();
                    
                    // Coordenadas relativas a la imagen visible
                    const relativeX = e.clientX - imgRect.left;
                    const relativeY = e.clientY - imgRect.top;
                    
                    // Convertir a coordenadas de imagen natural (sin importar zoom/pan)
                    const naturalX = (relativeX / imgRect.width) * img.naturalWidth;
                    const naturalY = (relativeY / imgRect.height) * img.naturalHeight;
                    
                    return {
                        relativeX,
                        relativeY,
                        naturalX,
                        naturalY,
                        imgRect,
                        valid: naturalX >= 0 && naturalY >= 0 && naturalX <= img.naturalWidth && naturalY <= img.naturalHeight
                    };
                }
                
                transformContainer.addEventListener('mousedown', function(e) {
                    if (!isEditMode) return;
                    
                    // SOLO procesar botón principal (izquierdo) para edición
                    if (e.button !== 0) return;
                    
                    // En modo lotes, NO permitir edición de puntos
                    if (editModeType === 'batches' && e.target.classList.contains('point')) {
                        e.preventDefault();
                        return;
                    }
                    
                    // Obtener coordenadas precisas con el nuevo sistema
                    const coords = getAccurateCoordinates(e);
                    
                    // Debug
                    console.log('Coordenadas precisas:', coords);
                    
                    if (editModeType === 'slabs') {
                        // Verificar que el click esté dentro de la imagen
                        if (!coords.valid) {
                            console.log('Click fuera de imagen');
                            return;
                        }
                        
                        const clickX = coords.naturalX;
                        const clickY = coords.naturalY;
                        
                        console.log('Punto creado en:', clickX, clickY);
                        
                        // Si se hizo click directamente sobre un punto
                        if (e.target.classList.contains('point')) {
                            const pointId = parseInt(e.target.dataset.pointId);
                            const pointIndex = manualPoints.findIndex(p => p.id === pointId);
                            
                            if (pointIndex >= 0) {
                                // Reemplazar punto existente (mover a nueva posición)
                                manualPoints[pointIndex] = {
                                    ...manualPoints[pointIndex],
                                    x: Math.round(clickX),
                                    y: Math.round(clickY),
                                    confidence: 1.0,
                                    isOriginal: false
                                };
                                
                                renderPoints();
                                autoSaveCurrentImageData(); // AUTO-GUARDADO
                            }
                            e.preventDefault();
                            return;
                        }
                        
                        // Buscar si hay un punto existente cerca (en coordenadas de pantalla)
                        const searchRadius = 30; // Radio fijo en píxeles de pantalla
                        const existingPointIndex = manualPoints.findIndex(point => {
                            // Convertir punto existente a coordenadas de pantalla
                            const pointScreenX = (point.x / img.naturalWidth) * coords.imgRect.width;
                            const pointScreenY = (point.y / img.naturalHeight) * coords.imgRect.height;
                            
                            // Distancia en coordenadas de pantalla
                            const distance = Math.sqrt(
                                Math.pow(pointScreenX - coords.relativeX, 2) + 
                                Math.pow(pointScreenY - coords.relativeY, 2)
                            );
                            return distance <= searchRadius;
                        });
                        
                        if (existingPointIndex >= 0) {
                            // Reemplazar punto existente
                            manualPoints[existingPointIndex] = {
                                ...manualPoints[existingPointIndex],
                                x: Math.round(clickX),
                                y: Math.round(clickY),
                                confidence: 1.0,
                                isOriginal: false
                            };
                        } else {
                            // Agregar nuevo punto
                            manualPoints.push({
                                id: nextPointId++,
                                x: Math.round(clickX),
                                y: Math.round(clickY),
                                confidence: 1.0,
                                isOriginal: false,
                                batchNumber: null,
                                isSelected: false
                            });
                        }
                        
                        renderPoints();
                        autoSaveCurrentImageData(); // AUTO-GUARDADO
                        e.preventDefault();
                        
                    } else if (editModeType === 'batches') {
                        // Modo de selección de lotes (selección libre)
                        if (!e.target.classList.contains('point')) {
                            isDrawing = true;
                            selectionPath = [];
                            
                            // Iniciar dibujado de selección libre
                            startFreeDrawing();
                            e.preventDefault();
                        }
                    }
                });
                
                transformContainer.addEventListener('mousemove', function(e) {
                    if (!isEditMode || editModeType !== 'batches' || !isDrawing) return;
                    
                    // ENFOQUE REVOLUCIONARIO: Coordenadas absolutas de pantalla
                    const img = document.getElementById('resultImg');
                    if (!img) return;
                    
                    // Verificar que el mouse esté sobre la imagen
                    const imgRect = img.getBoundingClientRect();
                    if (e.clientX < imgRect.left || e.clientX > imgRect.right ||
                        e.clientY < imgRect.top || e.clientY > imgRect.bottom) {
                        return; // Fuera de la imagen
                    }
                    
                    // Usar coordenadas ABSOLUTAS de pantalla (sin conversiones)
                    const screenX = e.clientX;
                    const screenY = e.clientY;
                    
                    // Añadir punto al path (coordenadas de pantalla)
                    const lastPoint = selectionPath[selectionPath.length - 1];
                    if (!lastPoint || 
                        Math.abs(screenX - lastPoint.x) > 3 || 
                        Math.abs(screenY - lastPoint.y) > 3) {
                        selectionPath.push({ x: screenX, y: screenY });
                        drawFreeSelection();
                        
                        console.log('Punto ABSOLUTO añadido:', { 
                            screenCoords: { x: screenX, y: screenY },
                            imgRect,
                            pathLength: selectionPath.length 
                        });
                    }
                });
                
                transformContainer.addEventListener('mouseup', function(e) {
                    if (!isEditMode || editModeType !== 'batches' || !isDrawing) return;
                    
                    isDrawing = false;
                    
                    // Cerrar el path de selección libre
                    if (selectionPath.length > 3) {
                        // Cerrar el path conectando el último punto con el primero
                        selectionPath.push(selectionPath[0]);
                        selectPointsInPath(selectionPath);
                        
                        // ABRIR POPUP AUTOMÁTICAMENTE DESPUÉS DE SELECCIÓN
                        setTimeout(() => {
                            const selectedPoints = manualPoints.filter(point => point.isSelected);
                            if (selectedPoints.length > 0) {
                                openBatchModal();
                            }
                        }, 100); // Pequeño delay para que termine la renderización
                    }
                });
                
                // Event listener para eliminar con click derecho (SOLO en modo slabs)
                transformContainer.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    if (!isEditMode || editModeType !== 'slabs') return;
                    
                    if (e.target.classList.contains('point')) {
                        const pointId = parseInt(e.target.dataset.pointId);
                        manualPoints = manualPoints.filter(p => p.id !== pointId);
                        renderPoints();
                        autoSaveCurrentImageData(); // AUTO-GUARDADO
                    }
                });
                
                // Manejo simple y efectivo del botón medio
                transformContainer.addEventListener('auxclick', function(e) {
                    if (e.button === 1) {
                        e.preventDefault();
                    }
                });
            }, 200);
            
            // Agregar zoom con puntos
            addZoomWithPoints('resultImg');
        }

        function renderPoints() {
            const img = document.getElementById('resultImg');
            const transformContainer = document.getElementById('transformContainer');
            
            if (!img || !transformContainer) return;
            
            // Obtener slabs existentes
            const existingPoints = transformContainer.querySelectorAll('.point');
            const existingPointsMap = new Map();
            existingPoints.forEach(p => {
                existingPointsMap.set(parseInt(p.dataset.pointId), p);
            });
            
            // Actualizar o crear slabs
            manualPoints.forEach(slab => {
                let slabElement = existingPointsMap.get(slab.id);
                
                if (!slabElement) {
                    // Crear nuevo slab
                    slabElement = document.createElement('div');
                    slabElement.dataset.pointId = slab.id;
                    transformContainer.appendChild(slabElement);
                }
                
                // Actualizar clases y contenido
                let className = 'point';
                if (slab.isSelected) {
                    className += ' selected';
                } else if (slab.batchNumber) {
                    className += ' batch';
                } else if (slab.isOriginal) {
                    className += ' original';
                } else {
                    className += ' manual';
                }
                slabElement.className = className;
                
                // Aplicar color específico del lote
                if (slab.batchNumber) {
                    const batchColor = getBatchColor(slab.batchNumber);
                    slabElement.style.backgroundColor = batchColor;
                    slabElement.textContent = slab.batchNumber;
                    slabElement.title = `Slab ${slab.id} - Lote: ${slab.batchNumber} - Confidence: ${slab.confidence.toFixed(2)}`;
                } else {
                    // Restaurar color por defecto y mostrar confidence
                    slabElement.style.backgroundColor = '';
                    slabElement.textContent = slab.confidence.toFixed(2);
                    slabElement.title = `Slab ${slab.id} - Confidence: ${slab.confidence.toFixed(2)}`;
                }
                
                // Actualizar posición (siempre)
                updatePointPosition(slabElement, slab, img);
                existingPointsMap.delete(slab.id);
            });
            
            // Remover slabs que ya no existen
            existingPointsMap.forEach(slabElement => {
                slabElement.remove();
            });
        }

        function updatePointPosition(pointElement, point, img) {
            // Convertir coordenadas de imagen original a coordenadas relativas a la imagen mostrada
            const x = (point.x / img.naturalWidth) * img.clientWidth;
            const y = (point.y / img.naturalHeight) * img.clientHeight;
            
            // Posicionar directamente
            pointElement.style.left = x + 'px';
            pointElement.style.top = y + 'px';
        }

        function resetImageTransform() {
            imageScale = 1;
            imageTranslateX = 0;
            imageTranslateY = 0;
        }

        function addZoomWithPoints(imgId) {
            const img = document.getElementById(imgId);
            const container = img.parentElement;
            
            // Crear contenedor interno que se transformará
            const transformContainer = document.createElement('div');
            transformContainer.id = 'transformContainer';
            transformContainer.style.cssText = `
                position: relative;
                display: inline-block;
                transform-origin: center center;
                transition: transform 0.1s ease-out;
            `;
            
            // Mover imagen al contenedor interno
            container.insertBefore(transformContainer, img);
            transformContainer.appendChild(img);
            
            let scale = 1;
            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let translateX = 0;
            let translateY = 0;
            
            // GUARDAR datos de zoom en el contenedor para acceso desde edición
            container._zoomData = {
                scale: scale,
                translateX: translateX,
                translateY: translateY
            };

            function constrainPosition() {
                const containerRect = container.getBoundingClientRect();
                const transformRect = transformContainer.getBoundingClientRect();
                
                const containerW = containerRect.width - 40;
                const containerH = containerRect.height - 40;
                const transformW = transformRect.width;
                const transformH = transformRect.height;

                if (transformW > containerW) {
                    const maxTranslateX = (transformW - containerW) / 2;
                    translateX = Math.max(-maxTranslateX, Math.min(maxTranslateX, translateX));
                } else {
                    translateX = 0;
                }

                if (transformH > containerH) {
                    const maxTranslateY = (transformH - containerH) / 2;
                    translateY = Math.max(-maxTranslateY, Math.min(maxTranslateY, translateY));
                } else {
                    translateY = 0;
                }
            }

            function updateTransform() {
                const transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
                transformContainer.style.transform = transform;
                
                // ACTUALIZAR datos guardados
                container._zoomData = {
                    scale: scale,
                    translateX: translateX,
                    translateY: translateY
                };
            }

            // Zoom con scroll
            container.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = scale * delta;
                
                if (newScale >= 1 && newScale <= 3.6) {
                    const prevScale = scale;
                    scale = newScale;
                    
                    const scaleRatio = scale / prevScale;
                    translateX *= scaleRatio;
                    translateY *= scaleRatio;
                    
                    updateTransform();
                    constrainPosition();
                    updateTransform();
                    
                    if (scale > 1) {
                        container.classList.add('zoomed');
                        img.style.cursor = 'grab';
                    } else {
                        container.classList.remove('zoomed');
                        img.style.cursor = 'crosshair';
                        translateX = 0;
                        translateY = 0;
                        updateTransform();
                    }
                }
            });

            // SOLUCIÓN ROBUSTA: Permitir botón scroll para pan Y mantener edición precisa
            transformContainer.addEventListener('mousedown', function(e) {
                // Botón izquierdo (0) o medio (1) para pan cuando hay zoom
                if (scale > 1 && (e.button === 0 || e.button === 1)) {
                    // Si es botón izquierdo Y estamos en modo edición, NO activar pan
                    if (e.button === 0 && isEditMode) {
                        return; // Dejar que la edición maneje esto
                    }
                    
                    isDragging = true;
                    startX = e.clientX - translateX;
                    startY = e.clientY - translateY;
                    img.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging && !isDrawing) {
                    translateX = e.clientX - startX;
                    translateY = e.clientY - startY;
                    
                    constrainPosition();
                    updateTransform();
                }
            });

            document.addEventListener('mouseup', function(e) {
                if (isDragging) {
                    isDragging = false;
                    img.style.cursor = scale > 1 ? 'grab' : 'crosshair';
                }
            });
            
            // Permitir auxclick del botón medio para funcionalidad nativa
            transformContainer.addEventListener('auxclick', function(e) {
                if (e.button === 1) {
                    e.preventDefault(); // Solo prevenir acción por defecto, no bloquear
                }
            });

            // Reset zoom con doble click
            img.addEventListener('dblclick', function() {
                scale = 1;
                translateX = 0;
                translateY = 0;
                updateTransform();
                container.classList.remove('zoomed');
                img.style.cursor = 'crosshair';
            });
        }

        function addZoomFunctionality(imgId) {
            const img = document.getElementById(imgId);
            const container = img.parentElement;
            let scale = 1;
            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let translateX = 0;
            let translateY = 0;

            function constrainPosition() {
                const containerRect = container.getBoundingClientRect();
                const imgRect = img.getBoundingClientRect();
                
                const containerW = containerRect.width - 40;
                const containerH = containerRect.height - 40;
                const imgW = imgRect.width;
                const imgH = imgRect.height;

                if (imgW > containerW) {
                    const maxTranslateX = (imgW - containerW) / 2;
                    translateX = Math.max(-maxTranslateX, Math.min(maxTranslateX, translateX));
                } else {
                    translateX = 0;
                }

                if (imgH > containerH) {
                    const maxTranslateY = (imgH - containerH) / 2;
                    translateY = Math.max(-maxTranslateY, Math.min(maxTranslateY, translateY));
                } else {
                    translateY = 0;
                }
            }

            // Zoom con scroll
            container.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = scale * delta;
                
                if (newScale >= 1 && newScale <= 3.6) {
                    const prevScale = scale;
                    scale = newScale;
                    
                    const scaleRatio = scale / prevScale;
                    translateX *= scaleRatio;
                    translateY *= scaleRatio;
                    
                    img.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
                    
                    setTimeout(() => {
                        constrainPosition();
                        img.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
                    }, 10);
                    
                    if (scale > 1) {
                        container.classList.add('zoomed');
                        img.style.cursor = 'grab';
                    } else {
                        container.classList.remove('zoomed');
                        img.style.cursor = 'zoom-in';
                        translateX = 0;
                        translateY = 0;
                        img.style.transform = `translate(0px, 0px) scale(1)`;
                    }
                }
            });

            // Drag para mover imagen cuando está en zoom
            img.addEventListener('mousedown', function(e) {
                if (scale > 1) {
                    isDragging = true;
                    startX = e.clientX - translateX;
                    startY = e.clientY - translateY;
                    img.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    translateX = e.clientX - startX;
                    translateY = e.clientY - startY;
                    
                    constrainPosition();
                    img.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
                }
            });

            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    img.style.cursor = scale > 1 ? 'grab' : 'zoom-in';
                }
            });

            // Reset zoom con doble click
            img.addEventListener('dblclick', function() {
                scale = 1;
                translateX = 0;
                translateY = 0;
                img.style.transform = 'translate(0px, 0px) scale(1)';
                container.classList.remove('zoomed');
                img.style.cursor = 'zoom-in';
            });
        }

        function showAlert(message, type) {
            // Remover alertas anteriores
            const existingAlerts = document.querySelectorAll('.alert');
            existingAlerts.forEach(alert => alert.remove());
            
            // Crear nueva alerta flotante
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.style.display = 'flex';
            alert.style.justifyContent = 'space-between';
            alert.style.alignItems = 'center';
            alert.style.padding = '12px 15px';
            
            // Crear contenido de mensaje
            const messageSpan = document.createElement('span');
            messageSpan.textContent = message;
            alert.appendChild(messageSpan);
            
            // Crear botón de cierre
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '✕';
            closeBtn.style.background = 'none';
            closeBtn.style.border = 'none';
            closeBtn.style.color = 'inherit';
            closeBtn.style.fontSize = '16px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.marginLeft = '10px';
            closeBtn.style.padding = '2px 6px';
            closeBtn.style.borderRadius = '3px';
            closeBtn.title = 'Cerrar';
            
            // Función para cerrar la alerta
            function closeAlert() {
                if (alert.parentNode) {
                    alert.style.animation = 'slideInRight 0.3s ease-out reverse';
                    setTimeout(() => {
                        if (alert.parentNode) {
                            alert.parentNode.removeChild(alert);
                        }
                    }, 300);
                }
            }
            
            closeBtn.onclick = closeAlert;
            alert.appendChild(closeBtn);
            
            // Insertar directamente en body para que flote
            document.body.appendChild(alert);
            
            // Remover después de 6 segundos (más tiempo para poder cerrar manualmente)
            setTimeout(closeAlert, 6000);
        }

        // Evitar doble click en upload area
        document.getElementById('uploadArea').addEventListener('click', function(e) {
            // Solo abrir file dialog si no es el botón
            if (!e.target.classList.contains('btn')) {
                document.getElementById('fileInput').click();
            }
        });

        // ===== GUARDADO AUTOMÁTICO AL CERRAR/REFRESCAR =====
        
        window.addEventListener('beforeunload', function(e) {
            // Guardar datos antes de cerrar/refrescar
            if (currentActiveImage) {
                console.log('🚨 GUARDADO DE EMERGENCIA antes de cerrar página');
                saveCurrentImageDataNow(); // Guardado síncrono
            }
        });
        
        // Guardado periódico cada 30 segundos
        setInterval(() => {
            if (currentActiveImage && (manualPoints.length > 0 || batches.length > 0)) {
                console.log('🕒 GUARDADO PERIÓDICO (30s)');
                autoSaveCurrentImageData();
            }
        }, 30000);
        
        // ===== INICIALIZACIÓN DE LA APLICACIÓN =====
        
        // Cargar datos persistentes al inicio (no bloqueante)
        window.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 Inicializando AZA Slab Counter v8.0 - Sistema Industrial...');
            
            // Cargar datos persistentes en segundo plano
            loadPersistentData().then(persistedData => {
                if (persistedData && persistedData.images.length > 0) {
                    console.log(`📦 ${persistedData.images.length} imágenes encontradas en persistencia:`);
                    
                    // Mostrar detalles de cada imagen
                    persistedData.images.forEach(img => {
                        const manualCount = img.manualPoints?.length || 0;
                        const batchCount = img.batches?.length || 0;
                        const status = batchCount > 0 ? `✅ ${batchCount} lotes` : 
                                      manualCount > 0 ? `🎯 ${manualCount} slabs` : '📁 sin datos';
                        console.log(`   📷 ${img.name}: ${status}`);
                    });
                    
                    // Verificar si hay optimización reciente
                    const optimizedAt = persistedData.optimized_at;
                    const isOptimized = optimizedAt && (Date.now() - new Date(optimizedAt).getTime()) < 24 * 60 * 60 * 1000; // 24 horas
                    
                    if (isOptimized) {
                        console.log('✅ PERSISTENCIA OPTIMIZADA recientemente');
                        showAlert(`📦 PERSISTENCIA OPTIMIZADA: ${persistedData.images.length} imagen(es) con datos guardados. Las imágenes con lotes se restaurarán automáticamente.`, 'success');
                    } else {
                        console.log('🔧 Optimizando persistencia...');
                        optimizePersistentData().then(success => {
                            if (success) {
                                showAlert(`📦 PERSISTENCIA ROBUSTA: ${persistedData.images.length} imagen(es) optimizadas. Sube las mismas imágenes para restaurar automáticamente todos los lotes.`, 'success');
                            }
                        });
                    }
                } else {
                    console.log('📁 No hay datos persistentes previos - sistema listo para nuevas imágenes');
                }
            }).catch(error => {
                console.log('⚠️ Error inicializando persistencia:', error);
                showAlert('⚠️ Error cargando datos persistentes. Creando nuevo sistema de persistencia...', 'warning');
            });
        });

        // ===== FUNCIONES PARA SELECCIÓN DE LOTES =====

        function switchEditMode(mode) {
            editModeType = mode;
            
            // Limpiar cualquier operación en curso
            isDrawing = false;
            selectionPath = [];
            hideFreeSelection();
            
            // Resetear estados potencialmente problemáticos
            const transformContainer = document.getElementById('transformContainer');
            if (transformContainer) {
                transformContainer.style.pointerEvents = 'auto';
            }
            
            // Actualizar botones
            document.getElementById('slabsMode').classList.toggle('active', mode === 'slabs');
            document.getElementById('batchesMode').classList.toggle('active', mode === 'batches');
            
            // Mostrar/ocultar controles de lotes
            document.getElementById('batchControls').classList.toggle('active', mode === 'batches');
            
            // Limpiar selección
            clearSelection();
            
            // Actualizar indicador
            updateEditModeIndicator();
            
            // Cambiar cursor según modo
            const img = document.getElementById('resultImg');
            if (img) {
                img.style.cursor = mode === 'slabs' ? 'crosshair' : 'crosshair';
            }
        }

        function updateEditModeIndicator() {
            const indicator = document.getElementById('editModeIndicator');
            if (editModeType === 'slabs') {
                indicator.innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-weight: bold; color: #008759; margin-bottom: 5px;">✏️ MODO: EDICIÓN DE SLABS</div>
                        <div style="font-size: 11px; color: #666;">
                            • <strong>Click izquierdo:</strong> Agregar nuevo slab o mover slab existente<br>
                            • <strong>Click derecho:</strong> Eliminar slab<br>
                            • <strong>Zoom:</strong> Rueda del mouse | <strong>Pan:</strong> Arrastrar con botón central
                        </div>
                    </div>
                `;
            } else {
                indicator.innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-weight: bold; color: #1947BA; margin-bottom: 5px;">📦 MODO: SELECCIÓN DE LOTES</div>
                        <div style="font-size: 11px; color: #666;">
                            • <strong>Arrastrar:</strong> Dibujar área libre para seleccionar slabs<br>
                            • <strong>Asignar lote:</strong> Ingresar número y presionar "Crear Lote"<br>
                            • <strong>Nota:</strong> No se pueden editar slabs individuales en este modo
                        </div>
                    </div>
                `;
            }
        }

        function clearSelection() {
            selectedSlabs = [];
            manualPoints.forEach(slab => slab.isSelected = false);
            document.getElementById('selectedCount').textContent = '0';
            document.getElementById('assignBatchBtn').disabled = true;
            renderPoints();
            hideFreeSelection();
            autoSaveCurrentImageData(); // AUTO-GUARDADO
        }

        function updateSelectedCount() {
            const count = selectedSlabs.length;
            document.getElementById('selectedCount').textContent = count;
            document.getElementById('assignBatchBtn').disabled = count === 0;
            // No auto-guardar aquí porque es solo UI
        }

        async function assignBatchToSelected() {
            const batchNumber = parseInt(document.getElementById('batchNumber').value);
            
            // VERIFICAR DUPLICADOS USANDO EL GESTOR CENTRALIZADO
            console.log(`🚀 [assignBatchToSelected] Iniciando verificación de duplicados para lote ${batchNumber}`);
            try {
                const resultado = await historialManager.verificarLoteDuplicado(batchNumber);
                console.log(`📋 [assignBatchToSelected] Resultado de verificación:`, resultado);
                
                // Función para continuar con la creación del lote
                const continuarCreacion = async () => {
                    await crearLoteConPuntosSeleccionados(batchNumber);
                };
                
                if (resultado.existe) {
                    console.log(`🚨 [assignBatchToSelected] MOSTRANDO MODAL DUPLICADO: Lote ${batchNumber} ya existe`);
                    // Mostrar modal de duplicado y esperar confirmación del usuario
                    mostrarModalDuplicado(batchNumber, resultado, continuarCreacion);
                } else {
                    console.log(`✅ [assignBatchToSelected] Lote ${batchNumber} es único, continuando con creación`);
                    await continuarCreacion();
                }
            } catch (error) {
                console.error('❌ [assignBatchToSelected] Error en verificación de duplicados:', error);
                // Continuar con la creación incluso si hay error en verificación
                await crearLoteConPuntosSeleccionados(batchNumber);
            }
        }
        
        async function crearLoteConPuntosSeleccionados(batchNumber) {
            // Siempre crear un nuevo lote, incluso si el número ya existe
            const batch = {
                number: batchNumber,
                points: [],
                imageName: currentImageName,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                id: Date.now() + Math.random() // ID único para diferenciar lotes con mismo número
            };
            batches.push(batch);
            
            selectedSlabs.forEach(pointId => {
                const point = manualPoints.find(p => p.id === pointId);
                if (point) {
                    // Remover de lotes anteriores
                    batches.forEach(b => {
                        b.points = b.points.filter(pid => pid !== pointId);
                    });
                    
                    // Asignar al nuevo lote
                    point.batchNumber = batchNumber;
                    point.isSelected = false;
                    batch.points.push(pointId);
                }
            });
            
            // Limpiar lotes vacíos
            batches = batches.filter(b => b.points.length > 0);
            
            selectedSlabs = [];
            nextBatchNumber = Math.max(nextBatchNumber, batchNumber + 1);
            document.getElementById('batchNumber').value = nextBatchNumber;
            
            updateSelectedCount();
            renderPoints();
            hideFreeSelection();
            autoSaveCurrentImageData(); // AUTO-GUARDADO
            updateImagesGrid(); // Actualizar estado en grid
            updateActiveImageInfo(); // Actualizar panel info
            
            // Guardar en historial CSV usando el gestor centralizado
            const guardadoExitoso = await historialManager.guardarLoteEnHistorial(
                currentImageName || 'imagen_sin_nombre', 
                batchNumber, 
                batch.points.length
            );
            
            if (guardadoExitoso) {
                showAlert(`✅ Lote ${batchNumber} creado con ${batch.points.length} slabs y guardado en historial`, 'success');
            } else {
                showAlert(`⚠️ Lote ${batchNumber} creado con ${batch.points.length} slabs pero hubo error guardando en historial`, 'warning');
            }
        }
        
        async function deleteBatch(batchNumber) {
            if (!confirm(`¿Estás seguro de eliminar el Lote ${batchNumber}?`)) {
                return;
            }
            
            // Encontrar el lote a eliminar
            const batchIndex = batches.findIndex(b => b.number === batchNumber);
            if (batchIndex === -1) {
                showAlert('❌ Lote no encontrado', 'error');
                return;
            }
            
            const batch = batches[batchIndex];
            
            // Remover asignación de lote de todos los puntos
            batch.points.forEach(pointId => {
                const point = manualPoints.find(p => p.id === pointId);
                if (point) {
                    point.batchNumber = null;
                    point.isSelected = false;
                }
            });
            
            // Eliminar el lote del array
            batches.splice(batchIndex, 1);
            
            // Actualizar interfaz
            renderPoints();
            autoSaveCurrentImageData(); // AUTO-GUARDADO
            updateImagesGrid(); // Actualizar estado en grid
            updateActiveImageInfo(); // Actualizar panel info
            
            // Eliminar del historial CSV usando el gestor centralizado
            const eliminadoExitoso = await historialManager.eliminarLoteDelHistorial(
                currentImageName || 'imagen_sin_nombre',
                batchNumber
            );
            
            if (eliminadoExitoso) {
                showAlert(`✅ Lote ${batchNumber} eliminado de la interfaz y del historial`, 'success');
            } else {
                showAlert(`⚠️ Lote ${batchNumber} eliminado de la interfaz pero hubo error eliminando del historial`, 'warning');
            }
            
            console.log(`Lote ${batchNumber} eliminado exitosamente`);
        }

        function startFreeDrawing() {
            // ENFOQUE COMPLETAMENTE DIFERENTE: SVG OVERLAY
            const imageContainer = document.getElementById('imageContainer');
            if (!imageContainer) return;
            
            // Eliminar overlay anterior si existe
            const oldOverlay = document.getElementById('selectionOverlay');
            if (oldOverlay) {
                oldOverlay.remove();
            }
            
            // Crear SVG overlay que cubre TODA la ventana
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.id = 'selectionOverlay';
            svg.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                pointer-events: none;
                z-index: 1000;
            `;
            
            // Crear path para el dibujo
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.id = 'selectionPath';
            path.setAttribute('stroke', '#1947BA');
            path.setAttribute('stroke-width', '3');
            path.setAttribute('fill', 'rgba(72, 52, 212, 0.2)');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('stroke-linejoin', 'round');
            
            svg.appendChild(path);
            document.body.appendChild(svg);
            
            console.log('SVG overlay creado - V5 enfoque mejorado');
        }
        
        function drawFreeSelection() {
            const pathElement = document.getElementById('selectionPath');
            if (!pathElement || selectionPath.length < 2) return;
            
            // Construir path SVG con coordenadas absolutas de pantalla
            let pathData = `M ${selectionPath[0].x} ${selectionPath[0].y}`;
            
            // Añadir puntos suaves
            for (let i = 1; i < selectionPath.length; i++) {
                pathData += ` L ${selectionPath[i].x} ${selectionPath[i].y}`;
            }
            
            // Si está cerca del punto inicial, cerrar
            if (selectionPath.length > 3) {
                const first = selectionPath[0];
                const last = selectionPath[selectionPath.length - 1];
                const distance = Math.sqrt(
                    Math.pow(first.x - last.x, 2) + Math.pow(first.y - last.y, 2)
                );
                
                if (distance < 30) {
                    pathData += ' Z'; // Cerrar path
                }
            }
            
            pathElement.setAttribute('d', pathData);
            
            console.log('SVG path actualizado V5:', {
                pathData: pathData.substring(0, 100) + '...',
                points: selectionPath.length
            });
        }
        
        function hideFreeSelection() {
            const overlay = document.getElementById('selectionOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Función para verificar si un punto está dentro de un polígono (ray casting)
        function pointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                if (((polygon[i].y > point.y) !== (polygon[j].y > point.y)) &&
                    (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }
        
        function selectPointsInPath(path) {
            const img = document.getElementById('resultImg');
            if (!img || path.length < 3) return;
            
            selectedSlabs = [];
            
            // Obtener posición actual de la imagen en pantalla
            const imgRect = img.getBoundingClientRect();
            
            manualPoints.forEach(point => {
                // Convertir coordenadas del punto a coordenadas de pantalla
                const pointScreenX = imgRect.left + (point.x / img.naturalWidth) * imgRect.width;
                const pointScreenY = imgRect.top + (point.y / img.naturalHeight) * imgRect.height;
                
                console.log('Verificando punto ABSOLUTO V5:', {
                    pointId: point.id,
                    naturalCoords: { x: point.x, y: point.y },
                    screenCoords: { x: pointScreenX, y: pointScreenY },
                    imgRect
                });
                
                // Verificar si el punto está dentro del path (coordenadas de pantalla)
                if (pointInPolygon({ x: pointScreenX, y: pointScreenY }, path)) {
                    selectedSlabs.push(point.id);
                    point.isSelected = true;
                } else {
                    point.isSelected = false;
                }
            });
            
            updateSelectedCount();
            renderPoints();
            autoSaveCurrentImageData(); // AUTO-GUARDADO
        }
        
        function generateBatchCSV() {
            // Usar los mismos datos del histórico que se muestran en "Ver Histórico de Lotes"
            fetch('/obtener_datos_historicos')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    if (data.data.length === 0) {
                        showAlert('No hay lotes en el histórico para exportar', 'error');
                        return;
                    }
                    
                    // Crear contenido CSV idéntico al del histórico
                    let csvContent = 'fecha,nombre_imagen,numero_lote,cantidad_slabs\n';
                    
                    // Ordenar por fecha descendente (igual que en la tabla histórica)
                    const datosOrdenados = data.data.sort((a, b) => new Date(b.fecha) - new Date(a.fecha));
                    
                    datosOrdenados.forEach(registro => {
                        csvContent += `"${registro.fecha}","${registro.nombre_imagen}",${registro.numero_lote},${registro.cantidad_slabs}\n`;
                    });
                    
                    // Crear y descargar archivo
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    
                    if (link.download !== undefined) {
                        const url = URL.createObjectURL(blob);
                        link.setAttribute('href', url);
                        link.setAttribute('download', `historico_lotes_${new Date().toISOString().slice(0,10)}.csv`);
                        link.style.visibility = 'hidden';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    }
                    
                    showAlert(`✅ CSV del histórico exportado con ${data.data.length} registros`, 'success');
                } else {
                    showAlert('Error obteniendo datos del histórico: ' + data.error, 'error');
                }
            })
            .catch(error => {
                console.error('Error descargando CSV del histórico:', error);
                showAlert('Error descargando CSV del histórico', 'error');
            });
        }
        
        function deleteBatch(batchNumber) {
            if (!currentActiveImage || !currentActiveImage.batches) {
                showAlert('❌ No hay imagen activa o no hay lotes', 'error');
                return;
            }
            
            if (!confirm(`¿Estás seguro de eliminar el Lote ${batchNumber}?`)) {
                return;
            }
            
            // Encontrar y eliminar el lote
            const batchIndex = currentActiveImage.batches.findIndex(batch => batch.number === batchNumber);
            
            if (batchIndex === -1) {
                showAlert('❌ Lote no encontrado', 'error');
                return;
            }
            
            // Obtener puntos del lote a eliminar
            const batchToDelete = currentActiveImage.batches[batchIndex];
            const pointsToRemove = batchToDelete.points;
            
            // Remover el lote del array
            currentActiveImage.batches.splice(batchIndex, 1);
            
            // RESTAURAR los puntos/detecciones del lote a estado original (con confidence)
            if (currentActiveImage.manualPoints) {
                // Restaurar los puntos que estaban en ese lote a su estado original
                currentActiveImage.manualPoints.forEach(point => {
                    const wasInDeletedBatch = pointsToRemove.some(p => p.id === point.id);
                    if (wasInDeletedBatch) {
                        // Restaurar a estado original de detección
                        point.batchNumber = null;
                        point.isSelected = false;
                        point.isAssigned = false;
                        // Los puntos mantienen su confidence original
                    }
                });
            }
            
            // Actualizar variables globales si es la imagen activa - RESTAURAR PUNTOS
            if (manualPoints) {
                manualPoints.forEach(point => {
                    const wasInDeletedBatch = pointsToRemove.some(p => p.id === point.id);
                    if (wasInDeletedBatch) {
                        // Restaurar a estado original de detección
                        point.batchNumber = null;
                        point.isSelected = false;
                        point.isAssigned = false;
                        // Los puntos mantienen su confidence original
                    }
                });
            }
            
            // Actualizar array global de batches
            batches = currentActiveImage.batches || [];
            
            // Guardar cambios
            autoSaveCurrentImageData();
            
            // Actualizar visualización
            renderPoints();
            updateActiveImageInfo();
            updateImagesGrid();
            
            // Sincronizar eliminación con histórico
            sincronizarEliminacionLoteHistorico(currentImageName || 'imagen_sin_nombre', batchNumber);
            
            showAlert(`✅ Lote ${batchNumber} eliminado correctamente`, 'success');
        }
        
        // ===== FUNCIONES PARA MODAL DE LOTE =====
        
        function openBatchModal() {
            const selectedPoints = manualPoints.filter(point => point.isSelected);
            
            if (selectedPoints.length === 0) {
                showAlert('❌ Primero selecciona slabs usando selección libre', 'error');
                return;
            }
            
            // Actualizar contador en modal
            document.getElementById('modalSelectedCount').textContent = selectedPoints.length;
            
            // Usar el último número de lote ingresado + 1
            let nextNumber = lastBatchNumber + 1;
            
            // Configurar modal
            document.getElementById('modalBatchNumber').value = nextNumber;
            document.getElementById('batchModal').style.display = 'block';
            
            // Focus en input para usabilidad
            setTimeout(() => {
                document.getElementById('modalBatchNumber').focus();
                document.getElementById('modalBatchNumber').select();
            }, 100);
        }
        
        function closeBatchModal() {
            document.getElementById('batchModal').style.display = 'none';
        }
        
        async function confirmBatchAssignment() {
            const batchNumber = parseInt(document.getElementById('modalBatchNumber').value);
            
            // Validar número
            if (!batchNumber || batchNumber < 1) {
                showAlert('❌ Por favor ingresa un número válido', 'error');
                return;
            }
            
            console.log(`🎯 [confirmBatchAssignment] Usuario confirma creación de lote ${batchNumber}`);
            
            // VERIFICAR DUPLICADOS USANDO EL GESTOR CENTRALIZADO
            const resultado = await historialManager.verificarLoteDuplicado(batchNumber);
            console.log(`📋 [confirmBatchAssignment] Resultado de verificación:`, resultado);
            
            // Función para continuar con la creación del lote
            const continuarCreacion = () => {
                // Actualizar último número de lote ingresado
                lastBatchNumber = batchNumber;
                
                // Cerrar modal
                closeBatchModal();
                
                // Ejecutar asignación usando la función existente pero con el número del modal
                assignBatchToSelectedWithNumber(batchNumber);
            };
            
            if (resultado.existe) {
                console.log(`🚨 [confirmBatchAssignment] MOSTRANDO MODAL DUPLICADO: Lote ${batchNumber} ya existe`);
                // Mostrar modal de duplicado y esperar confirmación del usuario
                mostrarModalDuplicado(batchNumber, resultado, continuarCreacion);
            } else {
                console.log(`✅ [confirmBatchAssignment] Lote ${batchNumber} es único, continuando con creación`);
                continuarCreacion();
            }
        }
        
        // Función auxiliar que usa el número del modal
        async function assignBatchToSelectedWithNumber(batchNumber) {
            const selectedPoints = manualPoints.filter(point => point.isSelected);
            
            if (selectedPoints.length === 0) {
                showAlert('❌ No hay slabs seleccionados', 'error');
                return;
            }
            
            // REORGANIZACIÓN INTELIGENTE: Detectar lotes afectados y manejar selección parcial
            const affectedBatches = new Set();
            const batchPointCounts = new Map(); // Para contar puntos por lote
            const selectedPointsFromBatches = new Map(); // Para contar puntos seleccionados por lote
            
            // Contar puntos totales y seleccionados por lote
            manualPoints.forEach(point => {
                if (point.batchNumber !== null && point.batchNumber !== undefined) {
                    // Contar puntos totales del lote
                    batchPointCounts.set(point.batchNumber, (batchPointCounts.get(point.batchNumber) || 0) + 1);
                    
                    // Si este punto está seleccionado, contarlo
                    if (point.isSelected) {
                        affectedBatches.add(point.batchNumber);
                        selectedPointsFromBatches.set(point.batchNumber, (selectedPointsFromBatches.get(point.batchNumber) || 0) + 1);
                    }
                }
            });
            
            // Procesar lotes afectados
            if (affectedBatches.size > 0) {
                console.log(`🔄 REORGANIZACIÓN INTELIGENTE: ${affectedBatches.size} lote(s) afectado(s)`);
                
                const reorganizationMessages = [];
                
                affectedBatches.forEach(batchNum => {
                    const totalPoints = batchPointCounts.get(batchNum) || 0;
                    const selectedFromThisBatch = selectedPointsFromBatches.get(batchNum) || 0;
                    const remainingPoints = totalPoints - selectedFromThisBatch;
                    
                    console.log(`   Lote ${batchNum}: ${selectedFromThisBatch}/${totalPoints} seleccionados, ${remainingPoints} quedan`);
                    
                    if (remainingPoints === 0) {
                        // Todo el lote fue seleccionado - eliminar lote completo
                        batches = batches.filter(batch => batch.number !== batchNum);
                        reorganizationMessages.push(`Lote ${batchNum} eliminado completamente (todos los puntos seleccionados)`);
                        
                        // Sincronizar eliminación con base de datos histórica usando gestor centralizado
                        historialManager.eliminarLoteDelHistorial(currentImageName || 'imagen_sin_nombre', batchNum);
                    } else {
                        // Selección parcial - actualizar lote existente para mantener solo puntos no seleccionados
                        const batchToUpdate = batches.find(batch => batch.number === batchNum);
                        if (batchToUpdate) {
                            // Mantener solo los puntos que NO fueron seleccionados
                            batchToUpdate.points = batchToUpdate.points.filter(batchPoint => {
                                const correspondingPoint = manualPoints.find(mp => mp.id === batchPoint.id);
                                return correspondingPoint && !correspondingPoint.isSelected;
                            });
                            reorganizationMessages.push(`Lote ${batchNum} actualizado: ${remainingPoints} puntos mantenidos, ${selectedFromThisBatch} movidos al nuevo lote`);
                            
                            // Sincronizar actualización de cantidad con base de datos histórica usando gestor centralizado
                            historialManager.actualizarLoteEnHistorial(currentImageName || 'imagen_sin_nombre', batchNum, batchNum, remainingPoints);
                        }
                    }
                });
                
                // Limpiar batchNumber solo de los puntos seleccionados
                selectedPoints.forEach(point => {
                    if (point.batchNumber !== null && point.batchNumber !== undefined) {
                        point.batchNumber = null;
                    }
                });
                
                // Actualizar referencia
                currentActiveImage.batches = batches;
                
                // Mostrar mensaje de reorganización
                showAlert(
                    `🔄 Reorganización inteligente completada:\n${reorganizationMessages.join('\n')}`,
                    'warning'
                );
            }
            
            // Crear el lote directamente - la verificación ya se hizo en confirmBatchAssignment
            await crearNuevoLoteConPuntos(batchNumber, selectedPoints);
        }
        
        
        async function crearNuevoLoteConPuntos(batchNumber, selectedPoints) {
            // Crear nuevo lote
            const newBatch = {
                number: batchNumber,
                points: selectedPoints.map(point => ({
                    id: point.id,
                    x: point.x,
                    y: point.y
                })),
                createdAt: new Date().toISOString(),
                color: getBatchColor(batchNumber),
                imageName: currentImageName
            };
            
            // Agregar lote
            batches.push(newBatch);
            
            // Actualizar puntos seleccionados con el nuevo lote
            selectedPoints.forEach(point => {
                point.batchNumber = batchNumber;
                point.isSelected = false;
            });
            
            // Limpiar selección
            clearSelection();
            
            // Actualizar interfaz
            renderPoints();
            updateActiveImageInfo();
            
            // Guardar cambios
            autoSaveCurrentImageData();
            updateImagesGrid();
            
            // Guardar en historial CSV usando el gestor centralizado
            const guardadoExitoso = await historialManager.guardarLoteEnHistorial(
                currentImageName || 'imagen_sin_nombre', 
                batchNumber, 
                newBatch.points.length
            );
            
            if (guardadoExitoso) {
                showAlert(`✅ Lote ${batchNumber} creado con ${newBatch.points.length} slabs y guardado en historial`, 'success');
            } else {
                showAlert(`⚠️ Lote ${batchNumber} creado con ${newBatch.points.length} slabs pero hubo error guardando en historial`, 'warning');
            }
        }
        
        // ===== GESTOR CENTRALIZADO DE HISTORIAL CSV =====
        
        class HistorialManager {
            constructor() {
                this.cache = new Map(); // Cache local para evitar múltiples consultas
                this.lastUpdate = null;
            }
            
            async obtenerHistorialCompleto() {
                try {
                    const response = await fetch('/obtener_datos_historicos');
                    const data = await response.json();
                    
                    if (data.success) {
                        // Actualizar cache
                        this.cache.clear();
                        data.data.forEach(registro => {
                            const key = `${registro.numero_lote}`;
                            if (!this.cache.has(key)) {
                                this.cache.set(key, []);
                            }
                            this.cache.get(key).push(registro);
                        });
                        this.lastUpdate = Date.now();
                        console.log(`📊 Cache de historial actualizado: ${data.data.length} registros, ${this.cache.size} lotes únicos`);
                        return data.data;
                    } else {
                        console.error('❌ Error obteniendo historial:', data.error);
                        return [];
                    }
                } catch (error) {
                    console.error('❌ Error de conexión al obtener historial:', error);
                    return [];
                }
            }
            
            async verificarLoteDuplicado(numeroLote, imagenActualAExcluir = null) {
                console.log(`🔍 Verificando duplicado para lote ${numeroLote}${imagenActualAExcluir ? ` (excluyendo imagen: ${imagenActualAExcluir})` : ''}`);
                
                // Obtener historial actualizado
                await this.obtenerHistorialCompleto();
                
                // Buscar en cache
                let registrosDelLote = this.cache.get(String(numeroLote)) || [];
                
                // FILTRAR registros que NO sean de la imagen actual (cuando estamos editando un lote existente)
                if (imagenActualAExcluir) {
                    registrosDelLote = registrosDelLote.filter(registro => 
                        registro.nombre_imagen !== imagenActualAExcluir
                    );
                    console.log(`📋 Después de filtrar imagen ${imagenActualAExcluir}: ${registrosDelLote.length} registros restantes`);
                }
                
                if (registrosDelLote && registrosDelLote.length > 0) {
                    // Encontrar el registro más reciente
                    const registroMasReciente = registrosDelLote.reduce((mas_reciente, actual) => {
                        return new Date(actual.fecha) > new Date(mas_reciente.fecha) ? actual : mas_reciente;
                    });
                    
                    console.log(`⚠️ Lote ${numeroLote} encontrado en historial:`, registroMasReciente);
                    return {
                        existe: true,
                        ubicacion: `${registroMasReciente.nombre_imagen} (histórico)`,
                        ultimaFecha: registroMasReciente.fecha,
                        ultimaCantidad: registroMasReciente.cantidad_slabs,
                        totalOcurrencias: registrosDelLote.length
                    };
                } else {
                    console.log(`✅ Lote ${numeroLote} NO encontrado en historial${imagenActualAExcluir ? ' (excluyendo imagen actual)' : ''}`);
                    return {
                        existe: false,
                        ubicacion: null
                    };
                }
            }
            
            async guardarLoteEnHistorial(nombreImagen, numeroLote, cantidadSlabs) {
                console.log(`💾 Guardando en historial: ${nombreImagen} - Lote ${numeroLote} - ${cantidadSlabs} slabs`);
                
                try {
                    const response = await fetch('/guardar_lote_historico', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            nombre_imagen: nombreImagen,
                            numero_lote: numeroLote,
                            cantidad_slabs: cantidadSlabs
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        console.log('✅ Lote guardado exitosamente en historial');
                        // Invalidar cache para forzar actualización en próxima consulta
                        this.cache.clear();
                        return true;
                    } else {
                        console.error('❌ Error guardando lote:', data.error);
                        return false;
                    }
                } catch (error) {
                    console.error('❌ Error de conexión guardando lote:', error);
                    return false;
                }
            }
            
            async eliminarLoteDelHistorial(nombreImagen, numeroLote) {
                console.log(`🗑️ Eliminando del historial: ${nombreImagen} - Lote ${numeroLote}`);
                
                try {
                    // Obtener todos los registros para encontrar el específico a eliminar
                    const historial = await this.obtenerHistorialCompleto();
                    const registroAEliminar = historial.find(r => 
                        r.nombre_imagen === nombreImagen && 
                        parseInt(r.numero_lote) === parseInt(numeroLote)
                    );
                    
                    if (!registroAEliminar) {
                        console.warn(`⚠️ No se encontró registro a eliminar: ${nombreImagen} - Lote ${numeroLote}`);
                        return false;
                    }
                    
                    const response = await fetch('/eliminar_registro_historico', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            fecha_original: registroAEliminar.fecha
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        console.log('✅ Registro eliminado exitosamente del historial');
                        this.cache.clear();
                        return true;
                    } else {
                        console.error('❌ Error eliminando registro:', data.error);
                        return false;
                    }
                } catch (error) {
                    console.error('❌ Error eliminando del historial:', error);
                    return false;
                }
            }
            
            async actualizarLoteEnHistorial(nombreImagen, numeroLoteAnterior, numeroLoteNuevo, cantidadSlabs) {
                console.log(`🔄 Actualizando historial: ${nombreImagen} - ${numeroLoteAnterior} → ${numeroLoteNuevo} (${cantidadSlabs} slabs)`);
                
                try {
                    const response = await fetch('/sincronizar_lotes_historico', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            nombre_imagen: nombreImagen,
                            numero_lote_anterior: numeroLoteAnterior,
                            numero_lote_nuevo: numeroLoteNuevo,
                            cantidad_slabs: cantidadSlabs
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        console.log('✅ Lote actualizado exitosamente en historial');
                        this.cache.clear();
                        return true;
                    } else {
                        console.error('❌ Error actualizando lote:', data.error);
                        return false;
                    }
                } catch (error) {
                    console.error('❌ Error actualizando historial:', error);
                    return false;
                }
            }
        }
        
        // Instancia global del gestor de historial
        const historialManager = new HistorialManager();
        
        // ===== FUNCIÓN DE TEST PARA VERIFICAR SISTEMA ROBUSTO =====
        
        async function testSistemaHistorial() {
            console.log('🧪 === INICIANDO TEST DEL SISTEMA DE HISTORIAL ROBUSTO ===');
            
            try {
                // Test 1: Verificar lote que sabemos que existe (7777)
                console.log('🧪 Test 1: Verificando lote 7777 (debe existir)');
                const resultado7777 = await historialManager.verificarLoteDuplicado(7777);
                console.log('🧪 Resultado:', resultado7777);
                
                if (resultado7777.existe) {
                    showAlert(`✅ TEST PASADO: Lote 7777 encontrado en "${resultado7777.ubicacion}"`, 'success');
                } else {
                    showAlert(`❌ TEST FALLIDO: Lote 7777 debería existir pero no se encontró`, 'error');
                }
                
                // Test 2: Verificar lote que no existe
                console.log('🧪 Test 2: Verificando lote 999999 (no debe existir)');
                const resultado999999 = await historialManager.verificarLoteDuplicado(999999);
                console.log('🧪 Resultado:', resultado999999);
                
                if (!resultado999999.existe) {
                    showAlert(`✅ TEST PASADO: Lote 999999 correctamente no encontrado`, 'success');
                } else {
                    showAlert(`❌ TEST FALLIDO: Lote 999999 no debería existir`, 'error');
                }
                
                // Test 3: Verificar cache
                console.log('🧪 Test 3: Verificando cache del gestor');
                console.log(`📊 Cache contiene ${historialManager.cache.size} lotes únicos`);
                
                if (historialManager.cache.size > 0) {
                    showAlert(`✅ TEST PASADO: Cache funciona correctamente (${historialManager.cache.size} lotes)`, 'success');
                } else {
                    showAlert(`⚠️ Cache vacío - puede ser normal si no hay datos`, 'warning');
                }
                
                console.log('🧪 === TEST DEL SISTEMA DE HISTORIAL COMPLETADO ===');
                
            } catch (error) {
                console.error('❌ Error en test del sistema:', error);
                showAlert(`❌ ERROR EN TEST: ${error.message}`, 'error');
            }
        }
        
        // ===== FUNCIONES DE BASE DE DATOS HISTÓRICA =====
        
        function guardarEnBaseDatosHistorica(nombreImagen, numeroLote, cantidadSlabs) {
            fetch('/guardar_lote_historico', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    nombre_imagen: nombreImagen,
                    numero_lote: numeroLote,
                    cantidad_slabs: cantidadSlabs
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('📊 Lote guardado en base de datos histórica:', data.message);
                } else {
                    console.error('❌ Error guardando en base de datos:', data.error);
                }
            })
            .catch(error => {
                console.error('❌ Error en petición a base de datos:', error);
            });
        }
        
        function mostrarTablaHistorica() {
            console.log('📊 Cargando tabla histórica...');
            
            fetch('/obtener_datos_historicos')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    llenarTablaHistorica(data.data);
                    
                    // Mostrar modal centrado
                    const modal = document.getElementById('tablaHistoricaModal');
                    modal.style.display = 'block';
                    modal.classList.add('centered');
                    
                    // Configurar listener para ESC
                    configurarCierreConESC();
                    
                    // Configurar filtros en tiempo real después de mostrar el modal
                    setTimeout(() => configurarFiltrosHistorico(), 100);
                } else {
                    showAlert('❌ Error cargando datos históricos: ' + data.error, 'error');
                }
            })
            .catch(error => {
                console.error('❌ Error cargando datos históricos:', error);
                showAlert('❌ Error de conexión al cargar datos históricos', 'error');
            });
        }
        
        // Variable global para almacenar todos los datos históricos
        let datosHistoricoCompletos = [];
        
        function llenarTablaHistorica(datos) {
            // Almacenar datos completos para filtrado
            datosHistoricoCompletos = datos;
            
            // Aplicar filtros
            const datosFiltrados = aplicarFiltrosHistorico(datos);
            
            const tbody = document.getElementById('tablaHistoricaBody');
            const contador = document.getElementById('contadorRegistros');
            tbody.innerHTML = '';
            
            if (datosFiltrados.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 20px; color: #999;">No hay datos que coincidan con los filtros</td></tr>';
                contador.innerHTML = `Mostrando 0 de ${datos.length} registros`;
                return;
            }
            
            // Ordenar por fecha descendente (más reciente primero) con manejo de errores
            datosFiltrados.sort((a, b) => {
                try {
                    const fechaA = a.fecha ? new Date(a.fecha) : new Date(0);
                    const fechaB = b.fecha ? new Date(b.fecha) : new Date(0);
                    return fechaB - fechaA;
                } catch (error) {
                    console.warn('Error ordenando fechas:', error);
                    return 0;
                }
            });
            
            datosFiltrados.forEach(registro => {
                const row = tbody.insertRow();
                row.style.borderBottom = '1px solid #eee';
                
                // Formatear fecha
                const fecha = new Date(registro.fecha);
                const fechaFormateada = fecha.toLocaleDateString() + ' ' + fecha.toLocaleTimeString();
                
                // Crear celdas individualmente para añadir funcionalidad de edición
                const celdaFecha = row.insertCell();
                celdaFecha.style.cssText = 'padding: 8px; border: 1px solid #ddd; background: #f0f0f0;';
                celdaFecha.textContent = fechaFormateada;
                celdaFecha.title = 'La fecha no es editable';
                
                const celdaImagen = row.insertCell();
                celdaImagen.style.cssText = 'padding: 8px; border: 1px solid #ddd;';
                celdaImagen.textContent = registro.nombre_imagen;
                
                const celdaLote = row.insertCell();
                celdaLote.style.cssText = 'padding: 8px; border: 1px solid #ddd; text-align: center; font-weight: bold;';
                celdaLote.textContent = registro.numero_lote;
                
                const celdaSlabs = row.insertCell();
                celdaSlabs.style.cssText = 'padding: 8px; border: 1px solid #ddd; text-align: center;';
                celdaSlabs.textContent = registro.cantidad_slabs;
                
                // Alternar color de filas
                if (tbody.children.length % 2 === 0) {
                    row.style.backgroundColor = '#f8f9fa';
                }
            });
            
            // Actualizar contador
            contador.innerHTML = `Mostrando ${datosFiltrados.length} de ${datos.length} registros`;
            
            console.log(`📊 Tabla histórica cargada con ${datosFiltrados.length} registros filtrados de ${datos.length} totales`);
        }
        
        function aplicarFiltrosHistorico(datos) {
            const filtroImagen = document.getElementById('filtroImagen').value.toLowerCase().trim();
            const filtroLote = document.getElementById('filtroLote').value.trim();
            const filtroFechaDesde = document.getElementById('filtroFechaDesde').value;
            const filtroFechaHasta = document.getElementById('filtroFechaHasta').value;
            
            return datos.filter(registro => {
                // Filtro por imagen
                if (filtroImagen && !registro.nombre_imagen.toLowerCase().includes(filtroImagen)) {
                    return false;
                }
                
                // Filtro por número de lote
                if (filtroLote && registro.numero_lote.toString() !== filtroLote) {
                    return false;
                }
                
                // Filtro por rango de fechas
                const fechaRegistro = new Date(registro.fecha);
                if (filtroFechaDesde) {
                    const fechaDesde = new Date(filtroFechaDesde);
                    if (fechaRegistro < fechaDesde) {
                        return false;
                    }
                }
                
                if (filtroFechaHasta) {
                    const fechaHasta = new Date(filtroFechaHasta);
                    fechaHasta.setHours(23, 59, 59, 999); // Final del día
                    if (fechaRegistro > fechaHasta) {
                        return false;
                    }
                }
                
                return true;
            });
        }
        
        function limpiarFiltrosHistorico() {
            document.getElementById('filtroImagen').value = '';
            document.getElementById('filtroLote').value = '';
            document.getElementById('filtroFechaDesde').value = '';
            document.getElementById('filtroFechaHasta').value = '';
            
            // Recargar tabla sin filtros
            llenarTablaHistorica(datosHistoricoCompletos);
        }
        
        // Configurar event listeners para filtros en tiempo real
        function configurarFiltrosHistorico() {
            const filtroImagen = document.getElementById('filtroImagen');
            const filtroLote = document.getElementById('filtroLote');
            const filtroFechaDesde = document.getElementById('filtroFechaDesde');
            const filtroFechaHasta = document.getElementById('filtroFechaHasta');
            
            // Aplicar filtros con debounce para mejorar rendimiento
            let timeoutId;
            const aplicarFiltrosConDebounce = () => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    llenarTablaHistorica(datosHistoricoCompletos);
                }, 300);
            };
            
            if (filtroImagen) filtroImagen.addEventListener('input', aplicarFiltrosConDebounce);
            if (filtroLote) filtroLote.addEventListener('input', aplicarFiltrosConDebounce);
            if (filtroFechaDesde) filtroFechaDesde.addEventListener('change', () => llenarTablaHistorica(datosHistoricoCompletos));
            if (filtroFechaHasta) filtroFechaHasta.addEventListener('change', () => llenarTablaHistorica(datosHistoricoCompletos));
        }
        
        function cerrarTablaHistorica() {
            document.getElementById('tablaHistoricaModal').style.display = 'none';
            document.getElementById('tablaHistoricaModal').classList.remove('centered');
            
            // Remover listener de ESC
            document.removeEventListener('keydown', historialESCListener);
        }
        
        // ===== FUNCIONES PARA MODAL DE LOTES DUPLICADOS =====
        
        function mostrarModalDuplicado(numeroLote, resultado, callback) {
            // Llenar detalles del duplicado
            const detallesDiv = document.getElementById('duplicadoDetalles');
            detallesDiv.innerHTML = `
                <div style="margin-bottom: 8px;"><strong>🏷️ Número de Lote:</strong> ${numeroLote}</div>
                <div style="margin-bottom: 8px;"><strong>📁 Imagen:</strong> ${resultado.ubicacion.replace(' (histórico)', '')}</div>
                <div style="margin-bottom: 8px;"><strong>📊 Cantidad de Slabs:</strong> ${resultado.ultimaCantidad}</div>
                <div style="margin-bottom: 8px;"><strong>📅 Última Fecha:</strong> ${new Date(resultado.ultimaFecha).toLocaleString()}</div>
                <div style="margin-bottom: 8px;"><strong>🔢 Total de Usos:</strong> ${resultado.totalOcurrencias}</div>
            `;
            
            // Configurar botón OK
            const okBtn = document.getElementById('duplicadoOkBtn');
            okBtn.onclick = function() {
                cerrarModalDuplicado();
                if (callback) callback();
            };
            
            // Mostrar modal
            document.getElementById('duplicadoModal').style.display = 'block';
            
            // Configurar ESC para cerrar
            const escListener = function(e) {
                if (e.key === 'Escape') {
                    cerrarModalDuplicado();
                    if (callback) callback();
                    document.removeEventListener('keydown', escListener);
                }
            };
            document.addEventListener('keydown', escListener);
        }
        
        function cerrarModalDuplicado() {
            document.getElementById('duplicadoModal').style.display = 'none';
        }
        
        // ===== FUNCIÓN PARA CIERRE CON ESC =====
        
        let historialESCListener = null;
        
        function configurarCierreConESC() {
            // Remover listener anterior si existe
            if (historialESCListener) {
                document.removeEventListener('keydown', historialESCListener);
            }
            
            // Crear nuevo listener
            historialESCListener = function(e) {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('tablaHistoricaModal');
                    if (modal && modal.style.display === 'block') {
                        cerrarTablaHistorica();
                    }
                }
            };
            
            // Agregar listener
            document.addEventListener('keydown', historialESCListener);
        }
        
        function descargarCSVHistorico() {
            fetch('/obtener_datos_historicos')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Crear contenido CSV
                    let csvContent = 'fecha,nombre_imagen,numero_lote,cantidad_slabs\n';
                    
                    // Ordenar por fecha descendente
                    const datosOrdenados = data.data.sort((a, b) => new Date(b.fecha) - new Date(a.fecha));
                    
                    datosOrdenados.forEach(registro => {
                        csvContent += `"${registro.fecha}","${registro.nombre_imagen}",${registro.numero_lote},${registro.cantidad_slabs}\n`;
                    });
                    
                    // Crear y descargar archivo
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    const url = URL.createObjectURL(blob);
                    
                    link.setAttribute('href', url);
                    link.setAttribute('download', `historico_lotes_${new Date().toISOString().split('T')[0]}.csv`);
                    link.style.visibility = 'hidden';
                    
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    showAlert('✅ CSV histórico descargado exitosamente', 'success');
                } else {
                    showAlert('❌ Error descargando CSV: ' + data.error, 'error');
                }
            })
            .catch(error => {
                console.error('❌ Error descargando CSV:', error);
                showAlert('❌ Error de conexión al descargar CSV', 'error');
            });
        }
        
        // ===== FUNCIONES DE EDICIÓN REMOVIDAS =====
        // La tabla histórica ya no es editable por diseño
        
        // ===== FUNCIÓN PARA EDITAR NÚMEROS DE LOTE EN PANEL ACTIVO =====
        
        async function editarNumeroLote(numeroLoteActual) {
            console.log(`✏️ Iniciando edición de lote ${numeroLoteActual}`);
            
            // Buscar el elemento span editable
            const spanElement = document.querySelector(`[data-batch-id="${numeroLoteActual}"]`);
            if (!spanElement) {
                showAlert('❌ Error: No se encontró el elemento a editar', 'error');
                return;
            }
            
            const valorOriginal = numeroLoteActual;
            
            // Crear input para edición
            const input = document.createElement('input');
            input.type = 'number';
            input.value = valorOriginal;
            input.min = '1';
            input.step = '1';
            input.style.cssText = `
                width: 60px; 
                border: 2px solid #1947BA; 
                padding: 2px 4px; 
                font-size: 12px; 
                text-align: center;
                border-radius: 4px;
                background: white;
            `;
            
            // Reemplazar contenido del span
            spanElement.innerHTML = '';
            spanElement.appendChild(input);
            input.focus();
            input.select();
            
            // Función para guardar cambios
            const guardarCambios = async () => {
                const nuevoNumero = parseInt(input.value);
                
                // Validaciones
                if (!nuevoNumero || nuevoNumero < 1) {
                    showAlert('❌ El número de lote debe ser mayor a 0', 'error');
                    input.focus();
                    return;
                }
                
                if (nuevoNumero === valorOriginal) {
                    // Sin cambios
                    cancelarEdicion();
                    return;
                }
                
                console.log(`💾 Guardando cambio: ${valorOriginal} → ${nuevoNumero}`);
                console.log(`📷 Imagen actual para excluir: ${currentImageName || 'imagen_sin_nombre'}`);
                
                try {
                    // VERIFICAR DUPLICADOS ANTES DE CAMBIAR (excluyendo la imagen actual)
                    const resultado = await historialManager.verificarLoteDuplicado(
                        nuevoNumero, 
                        currentImageName || 'imagen_sin_nombre'
                    );
                    
                    const continuarCambio = async () => {
                        // Actualizar el lote en la estructura de datos
                        const success = await actualizarNumeroLoteEnEstructura(valorOriginal, nuevoNumero);
                        
                        if (success) {
                            // Actualizar interfaz
                            spanElement.innerHTML = nuevoNumero;
                            spanElement.setAttribute('data-batch-id', nuevoNumero);
                            spanElement.onclick = () => editarNumeroLote(nuevoNumero);
                            
                            // Actualizar toda la interfaz para reflejar el cambio
                            renderPoints();
                            updateActiveImageInfo();
                            autoSaveCurrentImageData();
                            updateImagesGrid();
                            
                            showAlert(`✅ Lote actualizado: ${valorOriginal} → ${nuevoNumero}`, 'success');
                        } else {
                            cancelarEdicion();
                        }
                    };
                    
                    if (resultado.existe) {
                        console.log(`🚨 Lote ${nuevoNumero} ya existe, mostrando modal`);
                        mostrarModalDuplicado(nuevoNumero, resultado, continuarCambio);
                    } else {
                        await continuarCambio();
                    }
                    
                } catch (error) {
                    console.error('❌ Error editando número de lote:', error);
                    showAlert('❌ Error al actualizar el lote', 'error');
                    cancelarEdicion();
                }
            };
            
            // Función para cancelar edición
            const cancelarEdicion = () => {
                spanElement.innerHTML = valorOriginal;
                spanElement.onclick = () => editarNumeroLote(valorOriginal);
            };
            
            // Event listeners
            input.addEventListener('blur', guardarCambios);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    guardarCambios();
                } else if (e.key === 'Escape') {
                    cancelarEdicion();
                }
            });
        }
        
        async function actualizarNumeroLoteEnEstructura(numeroAnterior, numeroNuevo) {
            try {
                console.log(`🔍 Buscando lote ${numeroAnterior} en estructuras de datos...`);
                console.log(`📊 Batches globales:`, batches.map(b => ({ number: b.number, points: b.points.length })));
                console.log(`📷 Batches de imagen activa:`, currentActiveImage?.batches?.map(b => ({ number: b.number, points: b.points.length })));
                
                // BÚSQUEDA FLEXIBLE: buscar por numeroAnterior O numeroNuevo (en caso de que ya haya sido actualizado)
                let lote = null;
                let loteIndex = -1;
                let cantidadSlabs = 0;
                let loteEncontradoEn = '';
                
                // Buscar primero por numeroAnterior
                if (currentActiveImage && currentActiveImage.batches) {
                    loteIndex = currentActiveImage.batches.findIndex(batch => batch.number === numeroAnterior);
                    if (loteIndex !== -1) {
                        lote = currentActiveImage.batches[loteIndex];
                        cantidadSlabs = lote.points.length;
                        loteEncontradoEn = 'currentActiveImage.batches (por número anterior)';
                        console.log(`✅ Lote ${numeroAnterior} encontrado en currentActiveImage.batches`);
                    }
                }
                
                if (!lote) {
                    loteIndex = batches.findIndex(batch => batch.number === numeroAnterior);
                    if (loteIndex !== -1) {
                        lote = batches[loteIndex];
                        cantidadSlabs = lote.points.length;
                        loteEncontradoEn = 'batches globales (por número anterior)';
                        console.log(`✅ Lote ${numeroAnterior} encontrado en batches globales`);
                    }
                }
                
                // Si no se encontró por numeroAnterior, buscar por numeroNuevo (ya podría estar actualizado)
                if (!lote && currentActiveImage && currentActiveImage.batches) {
                    loteIndex = currentActiveImage.batches.findIndex(batch => batch.number === numeroNuevo);
                    if (loteIndex !== -1) {
                        lote = currentActiveImage.batches[loteIndex];
                        cantidadSlabs = lote.points.length;
                        loteEncontradoEn = 'currentActiveImage.batches (por número nuevo - ya actualizado)';
                        console.log(`✅ Lote ${numeroNuevo} encontrado en currentActiveImage.batches (ya actualizado)`);
                    }
                }
                
                if (!lote) {
                    loteIndex = batches.findIndex(batch => batch.number === numeroNuevo);
                    if (loteIndex !== -1) {
                        lote = batches[loteIndex];
                        cantidadSlabs = lote.points.length;
                        loteEncontradoEn = 'batches globales (por número nuevo - ya actualizado)';
                        console.log(`✅ Lote ${numeroNuevo} encontrado en batches globales (ya actualizado)`);
                    }
                }
                
                // Si aún no se encuentra, intentar sincronizar solo con CSV
                if (!lote) {
                    console.warn(`⚠️ Lote ${numeroAnterior} NO encontrado en estructuras, pero continuando con sincronización CSV`);
                    // Asumir una cantidad por defecto basada en puntos manuales
                    cantidadSlabs = manualPoints.filter(p => p.batchNumber === numeroAnterior || p.batchNumber === numeroNuevo).length;
                    console.log(`📊 Cantidad estimada de slabs desde puntos manuales: ${cantidadSlabs}`);
                    
                    // Solo sincronizar CSV sin actualizar estructuras locales
                    const sincronizacionExitosa = await historialManager.actualizarLoteEnHistorial(
                        currentImageName || 'imagen_sin_nombre',
                        numeroAnterior,
                        numeroNuevo,
                        cantidadSlabs
                    );
                    
                    if (sincronizacionExitosa) {
                        console.log(`✅ Sincronización CSV exitosa sin actualizar estructuras locales`);
                        return true;
                    } else {
                        console.error(`❌ Error en sincronización CSV`);
                        return false;
                    }
                }
                
                console.log(`📍 Lote encontrado en: ${loteEncontradoEn}`);
                
                // Solo actualizar si el lote aún no tiene el número nuevo
                if (lote.number !== numeroNuevo) {
                    lote.number = numeroNuevo;
                    console.log(`✅ Número actualizado en lote encontrado: ${numeroAnterior} → ${numeroNuevo}`);
                } else {
                    console.log(`ℹ️ El lote ya tiene el número ${numeroNuevo}, omitiendo actualización local`);
                }
                
                // Actualizar en TODAS las estructuras para mantener consistencia
                // Batches globales
                batches.forEach(batch => {
                    if (batch.number === numeroAnterior) {
                        batch.number = numeroNuevo;
                        console.log(`✅ Actualizado lote en batches globales: ${numeroAnterior} → ${numeroNuevo}`);
                    }
                });
                
                // Batches de imagen activa
                if (currentActiveImage && currentActiveImage.batches) {
                    currentActiveImage.batches.forEach(batch => {
                        if (batch.number === numeroAnterior) {
                            batch.number = numeroNuevo;
                            console.log(`✅ Actualizado lote en currentActiveImage.batches: ${numeroAnterior} → ${numeroNuevo}`);
                        }
                    });
                }
                
                // Actualizar los puntos manuales que pertenecen a este lote
                let puntosActualizados = 0;
                manualPoints.forEach(point => {
                    if (point.batchNumber === numeroAnterior) {
                        point.batchNumber = numeroNuevo;
                        puntosActualizados++;
                    }
                });
                console.log(`✅ Actualizado ${puntosActualizados} puntos manuales: ${numeroAnterior} → ${numeroNuevo}`);
                
                // Sincronizar con el historial CSV usando el gestor centralizado
                const sincronizacionExitosa = await historialManager.actualizarLoteEnHistorial(
                    currentImageName || 'imagen_sin_nombre',
                    numeroAnterior,
                    numeroNuevo,
                    cantidadSlabs
                );
                
                if (!sincronizacionExitosa) {
                    console.warn('⚠️ Advertencia: Error sincronizando con historial CSV');
                    showAlert('⚠️ Lote actualizado localmente pero hubo error sincronizando con historial', 'warning');
                }
                
                console.log(`✅ Lote actualizado exitosamente: ${numeroAnterior} → ${numeroNuevo}`);
                return true;
                
            } catch (error) {
                console.error('❌ Error actualizando estructura de lote:', error);
                showAlert('❌ Error actualizando el lote', 'error');
                return false;
            }
        }
        
        // ===== FUNCIONES DE SINCRONIZACIÓN CON HISTÓRICO =====
        
        function sincronizarEliminacionLoteHistorico(nombreImagen, numeroLote) {
            // Eliminar registros del histórico que correspondan a este lote
            fetch('/obtener_datos_historicos')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Buscar registros del lote eliminado
                    const registrosAEliminar = data.data.filter(registro => 
                        registro.nombre_imagen === nombreImagen && 
                        parseInt(registro.numero_lote) === parseInt(numeroLote)
                    );
                    
                    // Eliminar cada registro encontrado
                    const promesasEliminacion = registrosAEliminar.map(registro => 
                        fetch('/eliminar_registro_historico', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                fecha_original: registro.fecha
                            })
                        })
                    );
                    
                    Promise.all(promesasEliminacion)
                    .then(() => {
                        console.log(`📊 Eliminados ${registrosAEliminar.length} registros del histórico para lote ${numeroLote}`);
                    })
                    .catch(error => {
                        console.error('❌ Error eliminando registros del histórico:', error);
                    });
                }
            })
            .catch(error => {
                console.error('❌ Error obteniendo datos para eliminar del histórico:', error);
            });
        }
        
        function sincronizarCambioLoteHistorico(nombreImagen, numeroLoteAnterior, numeroLoteNuevo, cantidadSlabs) {
            fetch('/sincronizar_lotes_historico', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    nombre_imagen: nombreImagen,
                    numero_lote_anterior: numeroLoteAnterior,
                    numero_lote_nuevo: numeroLoteNuevo,
                    cantidad_slabs: cantidadSlabs
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('📊 Lote sincronizado con histórico exitosamente');
                } else {
                    console.error('❌ Error sincronizando lote:', data.error);
                }
            })
            .catch(error => {
                console.error('❌ Error en sincronización de lote:', error);
            });
        }
        
        // Permitir confirmar con Enter en el modal
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('modalBatchNumber').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    confirmBatchAssignment();
                }
            });
            
            // Cerrar modal con Escape
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.getElementById('batchModal').style.display === 'block') {
                    closeBatchModal();
                }
            });
        });
        
    </script>
</body>
</html>